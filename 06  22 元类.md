

属性名, 模块名不用引号

1. import mini_frame #mini_frame是模块的名字, 不是变量

2. setattr(self, name, value) # self 实例对象, name是属性名, value是变量

   1. ```
      class A():
      	bar = 10
      	
      a = A()
      1. getattr(a, 'bar')          # 获取属性 bar 值
      2. setattr(a, 'bar', 5)       # 设置属性 bar 值
      ```

      

### 22 元类 实现ORM

###### 文档版本

#### 22.1 元类

##### 类 是对象

1. 类 : 描述 生成一个对象的 代码段.  python等多数语言都是这个观点

   1. 示例

      ```
      class ObjectCreator(object):
      	pass
      ```

      ```
      my_object = ObjectCreator()
      print(my_object)  #<__main__.ObjectCreator object at 0x8974f2c>
      ```

2. 类 是 对象

   1. 关键字class，Python解释器 执行它 创建一个 类对象

   2. ```
      class ObjectCreator(object):
      	pass
      ```

      1. python解释器 的执行过程
         1. 内存中创建一个`类对象`，名字`ObjectCreator`。
         2. 类对象`ObjectCreator`  有创建 `实例对象` 的能力

   3. 类对象 本质是 对象. 它的操作：

      1. 它赋值给一个变量  a = ObjectCreator
      2. 拷贝它    copy.copy(ObjectCreator)
      3. 为它增加属性   ObjectCreator.abc = 100
      4. 它作为函数参数 传递 .  函数 abc(ObjectCreator)

   4. 示例

      * ```
        class ObjectCreator(object):
            pass
        ```

        python解释器执行代码段后在 内存 中创建 `ObjectCreator类对象`

      * ```
        print(ObjectCreator)  #打印 类对象，因为它是对象
        ```

        out:  `<class '__main__.ObjectCreator'>`

      * ```
        def echo(o):
        	print(o)
        	
        echo(ObjectCreator)  #类对象做 参数 传给函数
        ```

        out:  `<class '__main__.ObjectCreator'>`

      * ```
        print(hasattr(ObjectCreator, 'new_attribute'))
        ```

        out:  `Fasle`

      * ```
        ObjectCreator.new_attribute = 'foo'  #类对象 增加属性
        print(hasattr(ObjectCreator, 'new_attribute'))
        ```

        out:  `True`

      * ```
        print(ObjectCreator.new_attribute)
        ```

        out: ` foo`

      * ```
        ObjectCreatorMirror = ObjectCreator  #类对象 赋值 给一个变量
        print(ObjectCreatorMirror())
        ```

        out:  `<__main__.ObjectCreator object at 0x8997b4c>`

3. 类/类实例的 hasattr, getattr, setattr, delattr方法

   1. 构建类

      1. ```
         class Animal(object):
             def __init__(self,name, zone):
                 self.name = name
                 self.zone = zone
         
             def bark(self):
                 print("The %s id barking..." % self.name)
                 
         #创建实例
         dog = Animal("Dog", "earth")
         ```

   2. hasattr(object, name)

      1. 参数:

         1. object可以是对象，类，模块，当前Py文件.
         2. name是一个给字符串数据类型，可以是变量（属性），函数（方法）。
         3. 如果name在object中存在，则返回Ture,否则返回False。

      2. 实例

      3. | 语句                 | 输出 |
         | -------------------- | ---- |
         | dog.name             | Dog  |
         | hasattr(dog, "name") | True |
         | hasattr(dog, "bark") | True |
         | hasattr(dog, "age")  | True |

      4. 类

         1. | 语句                     | 输出                                                         |
            | ------------------------ | ------------------------------------------------------------ |
            | Animal.name              | AttributeError: type object 'Animal' has no attribute 'name',  实例的属性, 不是类的属性 |
            | hasattr(Animal, "name")  | False                                                        |
            | hasattr(Animal, "bark")  | True                                                         |
            | hasattr(Animal, "color") | False                                                        |

   3. getattr(object, name)

      1. getattr与hasattr语法相同，返回的结果: 对应name的值或函数。

      2. 实例

      3. | 语句                         | 输出                                                         |
         | ---------------------------- | ------------------------------------------------------------ |
         | getattr(dog, "name", "None") | 'Dog'                                                        |
         | getattr(dog, "bark")         | <bound method Animal.bark of <__main__.Animal object at 0x0000000004BFE788>> |
         | getattr(dog, "bark")()       | The Dog id barking...                                        |
         | getattr(dog, 'age')          | 12                                                           |

      4. 类

      5. | 语句                             | 输出                                                         |
         | -------------------------------- | ------------------------------------------------------------ |
         | getattr(Animal,  "name", "None") | 'None',  实例的属性, 不是类的属性                            |
         | getattr(Animal, "bark")          | <function __main__.Animal.bark(self)>                        |
         | getattr(Animal, "bark")()        | TypeError: bark() missing 1 required positional argument: 'self' |
         | getattr(Animal, "age")           | 12                                                           |

   4. setattr(object, name, value)  #设置属性值

   5. 实例

      1. | 语句                                   | 输出  |
         | -------------------------------------- | ----- |
         | setattr(dog,"name","cat") <br>dog.name | 'cat' |
         | setattr(dog, "leg",4)<br>dog.leg       | 4     |

      2. 类

         1. | 语句                                         | 输出                                                        |
            | -------------------------------------------- | ----------------------------------------------------------- |
            | setattr(Animal,"name","cat") <br>Animal.name | 'cat'                                                       |
            | setattr(Animal, "leg",4) <br>Animal.leg      | AttributeError: type object 'Animal' has no attribute 'leg' |
            | hasattr(dog, "bark")                         | True                                                        |

   6. delattr(object, name)   #删除一个属性

      1. 实例

         1. | 语句                 | 输出                 |
            | -------------------- | -------------------- |
            | delattr(dog, "bark") | AttributeError: bark |

      2. 类

         1. | 语句                    | 输出 |
            | ----------------------- | ---- |
            | delattr(Animal, "bark") |      |

4. 函数创建类: 动态地创建类( 运行时创建 类)

   1. 原理: 类是对象，  运行时 创建它.  像其他任何对象一样 

   2. 定义函数中定义类，class关键字

      1. ```
         def choose_class(name):  #定义函数
         	if name == 'foo':
         		class Foo(object):  #定义类
         			pass
         		return Foo  # 返回 类对象Foo引用，不是类的实例对象
         	else:
         		class Bar(object):
         			pass
         		return Bar # 返回 类对象Bar引用，不是类的实例对象
         ```

      2. ```
         MyClass = choose_class('foo')  #调用函数,返回类对象引用，不是类实例
         print(MyClass)
         ```

      3. ```
         out:  <class '__main__.choose_class.<locals>.Foo'>
         ```

      4. ```
         print(MyClass())  #用类对象创建类实例对象
         ```

      5. out:  `<__main__.choose_class.<locals>.Foo object at 0x0000000003771B80>`

      

   3. 内建函数 type

      1. ```python
         type(1)  # 数值的类型, <type 'int'>
         type("1")   # 字符串的类型, <type 'str'>
         ```

      2. ```
         type(ObjectCreator())  #实例对象的 类型,<class '__main__.ObjectCreator'>
         type(ObjectCreator)  #类对象的 类型  <class 'type'>
         ```

5. type 手动创建类

   1. type（）函数语法

      1. type(object)    #返回类型

         1. 当传递单个参数时, 返回对象的`类型`. 它的值与 `object .__class__` 实例变量相同。

         2. ```
            x = 10
            type(x)  # int
            ```

      2. type(name, bases, dict)    #动态的创建类

         1. 参数: 当传递三个参数时，返回`类`。  动态创建类。
            1. name,  “名称”字符串, 类名称。 与类的`__name__`属性相同
               1. 名字用引号 ` "" , ''`
            2. bases,  “基”元组, 指定基类。 与类的`__bases__`属性相同
               1. 基类(父类),  没有引号`"", ''`，不是字符串
            3. dict ,  字典, 创建类主体。 与类的`__dict__`属性相同
               1. 添加的属性是 `类属性`， 不是 实例属性
               2. 键用引号 `"", ''`
         2. `Data1 = type('Data1', (object,), {'__doc__': 'Data1 Class', 'd_id': 10})`
         3. `type(类名, 父类名的元组（针对继承,可为空), 属性的字典（名称和值）)`

   2. type创建带 属性 的类

      1. type()创建类,  字典类型 指定类的属性

      2. 示例

         1. `Foo = type('Foo', (), {'bar': True})`

            1. 等价于

               ```
               class Foo(object):
               	bar = True
               ```

         2. 使用:

            ```
            Foo  #引用, <class '__main__.Foo'>
            Foo.bar  #True
            f = Foo()
            f  #<__main__.Foo object at 0x00000000038A3940>
            f.bar  #True
            ```

         3. 自动创建子类

            ```
            class FooChild(Foo):
            	pass
            ```

         4. type创建子类(手动创建类)

            ```
            FooChild = type('FooChild', (Foo,), {})
            
            FooChild  #<class '__main__.FooChild'>
            FooChild.bar  #bar属性从Foo继承
            ```

   3. type创建带 方法 的类

      1. 创建带实例方法的类

         1. 先创建 普通函数

            ```
            def echo_bar(self):  # 定义 一个普通的函数, 参数self
            	print(self.bar)
            ```

         2. type 创建类,  字典添加 类方法

            ```
            FooChild = type('FooChild', (Foo,), {'echo_bar1': echo_bar})  # 让FooChild类中的 'echo_bar1' 属性，指向了echo_bar函数
            ```

         3. 测试

            ```
            hasattr(Foo, 'echo_bar1')  # 判断Foo类 有`echo_bar1`属性, False
            hasattr(FooChild, 'echo_bar1')  #判断FooChild类 有`echo_bar1`属性, True
            ```

         4. 使用

            ```
            my_foo = FooChild()  #创建对象
            my_foo.echo_bar1()  #通过属性 调用添加的函数
            ```

            

      2. 创建带静态方法的类

         1. 先创建 静态函数

            ```
            @staticmethod
            def test_static():
            	print("static method ....")
            ```

         2. 再 type创建类,  字典添加类方法

            ```
            Foochild = type('Foochild', (Foo,), {"echo_bar1": echo_bar, "test_static1": test_static})
            ```

         3. 使用

            ```
            fooclid = Foochild()  #用类创建实例对象
            fooclid.test_static1  #<function test_static at 0x00000000038ADB80>
            fooclid.test_static1()  #调用类的函数, static method ....
            fooclid.echo_bar1()  #True
            ```

            

      3. 创建带类方法的类

         1. 先 定义 类函数

            ```
            @classmethod
            def test_class(cls):
            	print(cls.bar)
            ```

         2. 再 type创建类,  字典添加类方法

            ```
            Foochild = type('Foochild', (Foo,), {"echo_bar1":echo_bar, "test_static1": test_static, "test_class1": test_class})
            ```

         3. 使用

            ```
            fooclid = Foochild()  #创建对象
            fooclid.test_class1()  #调用类方法, True
            ```

         

   4. type 创建类 示例

      1. type 是手动创建类

      2. 定义父类, 定义各种方法

         ```
         #普通类
         class A(object):
             num = 100
         
         #普通方法
         def print_b(self):  #self参数
             print(self.num)
         
         #静态方法
         @staticmethod
         def print_static():
             print("----haha-----")
         
         #类方法
         @classmethod
         def print_class(cls):  #cls参数
             print(cls.num)
         ```

      3. 再 type创建类

         ```
         B = type("B", (A,), {"print_b": print_b, "print_static": print_static, "print_class": print_class})
         ```

      4. 使用

         ```
         b = B()
         b.print_b()  # 100
         b.print_static()  # ----haha-----
         b.print_class()  # 100
         ```

   5. 两 种创建类的对比

      1. ```
         #自动创建(过程)
         class Test:  #定义 Test类
         	pass
         
         Test()  #创建 Test类的 实例对象, <__main__.Test at 0x10d3f8438>
         ```

      2. ```
         #手动创建(过程)
         Test1 = type("Test2", (), {}) #定义Test1类, 名字是`Test2`
         
         Test1.__name__  #'Test2', 类的__name__属性的值是'Test2'
         Test1()  #创建Test1类的 实例对象,<__main__.Test2 object at 0x00000000038654F0>
         ```

         1. type函数 第1个实参，类的名字, 即`__name__`的值, 没有任何引用意义
         2. `help(Test1)`   #用help查看Test1类

##### 元类

1. type()

   1. 是 元类. 元类也是 类.  元类返回类, 是创建类的“东西”

   2. type 是 Python的内建 元类.  创建 所有类 的 元类

      1.  也可 创建自己的元类
      2.  Python中所有的东西 -- 都是对象, 包括整数、字符串、函数、类. 

   3. 小结: 元类 创建 类, 类 创建 实例对象. 理解:

      1. ```
         MyClass = MetaClass() #  元类创建 “类对象”
         my_object = MyClass() # “类对象” 创建 实例对象
         ```

2. 备注: 

   1. type元类: 小写  不用大写,  和 str 保持一致性，

   2. str类:  创建 字符串对象 的 类

   3. int类:  创建 整数对象 的 类

   4. `__class__` 查看 对象的类

      1. ```
         age = 35
         age.__class__  #<type 'int'>
         age.__class__.__class__  #<type 'type'>
         
         name = 'bob'
         name.__class__  #<type 'str'>
         name.__class__.__class__  ##<type 'type'>
         
         def foo(): pass
         foo.__class__  #<type 'function'>
         foo.__class__.__class__  #<type 'type'>
         
         class Bar(object): pass
         b = Bar()
         b.__class__  #<class '__main__.Bar'>
         b.__class__.__class__  #<type 'type'>
         
         int.__class__   #type
         str.__class__   #type
         ```

      

3. `__metaclass__`属性, 指定元类

   1. `__metaclass__` 指定元类创建类, 默认元类是 type

      1. Python2 用`__metaclass__` 创建 Foo类(对象)

         1. ```
            class Foo(bar):
                __metaclass__ = 类名引用, 返回类的函数引用,
                ......
            ```

      2. `__metaclass__` 的值:

         1. 指定新建类的元类
         2. 类似type,  type化的东东(如:  返回 `type()` 的函数)

   2. Python 创建类的过程

      1. 先检查Foo中有`__metaclass__`属性. 有，Python 用`__metaclass__`创建Foo类(对象)
      2. Foo没有,  则在Bar（父类）中找`__metaclass__`属性，用`__metaclass__`创建Foo类(对象)。
      3. Bar父类没有，则在 模块 中找`__metaclass__`，用`__metaclass__`创建Foo类(对象)
      4. 模块没有`__metaclass__`, Python 用内置的`type` 创建这个类对象

4. `__metaclass__` 与 `metaclass`

   1. 目的 : 创建类时指定元类. 元类能 自动地 改变生成的类

   2. python2用 类属性`__metaclass__` 指定元类,  可被任意赋值

      1. ```
         #思路引导, 工作中不用这种方法
         #-*- coding:utf-8 -*-
         def upper_attr(class_name, class_parents, class_attr):
         
             # class_name  类的名字 Foo
             # class_parents  父类 object
             # class_attr  字典的方式保存所有的类属性
         
             # 遍历属性字典，把不是__开头的属性名字变为大写
             new_attr = {}
             for name, value in class_attr.items():
                 if not name.startswith("__"):
                     new_attr[name.upper()] = value
         
             #调用type创建一个类
             #返回一个类
             return type(class_name, class_parents, new_attr)
         
         #指定元类创建类
         class Foo(object):
             __metaclass__ = upper_attr # 设置Foo类的元类为upper_attr
             bar = 'bip'
         ```

      2. ```
         hasattr(Foo, 'bar')  #True
         hasattr(Foo, 'BAR')  #False
         
         f = Foo()
         f.BAR #报错, AttributeError: 'Foo' object has no attribute 'BAR'
         f.bar  #'bip'
         ```

            

   3. python3 用 参数 metaclass 指定元类

      1. ```
         #-*- coding:utf-8 -*-
         #定义元类生成函数, 实际工作不用该方法
         #参数class_attr是字典类型
         def upper_attr(class_name, class_parents, class_attr):
         
             #遍历属性字典，把不是__开头的属性名字变为大写
             new_attr = {}
             for name,value in class_attr.items():
                 if not name.startswith("__"):
                 #bar变为了BAR
                     new_attr[name.upper()] = value
         
                     #调用type来创建一个类
             return type(class_name, class_parents, new_attr)
         ```

      2. ```
         #定义类, 指定元类
         class Foo(object, metaclass=upper_attr):
         	bar = 'bip'
         ```

         1. metaclass自动把子类的属性,方法封装为字典, 属性名方法名加引号做字典的键

         2. ```
            {'__module__': '__main__', '__qualname__': 'Foo', 'bar': 'bip'}
            {'__module__': '__main__', '__qualname__': 'Foo', 'bar': 'bip'}
            {'__module__': '__main__', '__qualname__': 'Foo', 'bar': 'bip'}
            ```

      3. ```
         hasattr(Foo, 'bar')  #False
         hasattr(Foo, 'BAR')  #True
         
         f = Foo()  
         f.BAR  #'bip'
         f.bar  #报错,AttributeError: 'Foo' object has no attribute 'bar'
         ```

         

   4. 定义一个真实的元类.

      1. 创建元类的方法

         1. type方法: 

            1. `type(class_name, class_parents, new_attr)`
            2. 可以用 type 创建普通的类, 也可以 用 type 创建元类

         2. `type.__new__`方法

            1.  `type.__new__(cls, class_name, class_parents, new_attr)` 
            2.  作用: 生成类对象

            3. new_attrs参数

               1. 必须是 dict 类型.
               2. 必须有`'__init__' : <function Foo.__init__ at 0xDAF>`  项才能带参数初始化
               3. 没有时, 可以不带参数初始化

         3. 两者的参数不同

      2. 创建一个真实的 元类

         1. ```
            #coding=utf-8
            
            #定义一个真实的元类
            class UpperAttrMetaClass(type):  #元类的父类是type
                #cls关键字指明是类方法, class_name 类名, class_parents 父类名 元组 名字没有引号, class_attr 属性字典
                def __new__(cls, class_name, class_parents, class_attr):
                    
                    new_attr = {}
                    #遍历属性字典, for循环, 一次取一个item
                    for name, value in class_attr.items():
                    	#不是__开头的属性名字变为大写
                        if not name.startswith("__"):
                            new_attr[name.upper()] = value
            
                    #方法1：type方法 创建类对象
                 	return type(class_name, class_parents, new_attr)
            
                    #方法2： type.__new__方法 创建类对象
                    #return type.__new__(cls, class_name, class_parents, new_attr)  #new_attr没有__init__键, 不能带参数初始化, 可以不带参数初始化
            ```

      3. python2 ,  用 `__metaclass__` 指定元类

         1. ```
            #python3 中不执行
            class Foo(object):
            	__metaclass__ = UpperAttrMetaClass
            	bar = 'bip'
            ```

      4. python3, 用 metaclass 指定元类

         1. ```
            class Foo(object, metaclass=UpperAttrMetaClass):
            	bar = 'bip'
            ```

         2. metaclass把类的方法,属性封装为字典, 传给元类

            1. 字典的键是加引号的属性名, 加引号的方法名
            2. 字典的值是属性值, 方法引用

      5. 使用

         1. ```
            hasattr(Foo, 'bar')  # 输出: False 
            hasattr(Foo, 'BAR')  # 输出:True
            f = Foo()
            f.BAR  # 输出:'bip'
            ```

   

   4. 元类中的`type.__new__(cls, class_name, bases, attrs)` 的attrs参数

      1. attrs参数中有`'__init__': <function Foo.__init__ at 0x0000000004E0DC18>`

         1. ```
            class UpperAttrMetaClass(type): 
                def __new__(cls, class_name, class_parents, attrs):
                    new_attr = {}
                    for name, value in  attrs.items():
                        print('Found mapping: %s ==> %s' % (name, value))
                        new_attr[name] = value
                    print("attrs", attrs)
                    print("new_attr", new_attr)           
                    return type.__new__(cls, class_name, class_parents, new_attr)
                    
            
            class Foo(metaclass=UpperAttrMetaClass):
                bar = 5    
                def __init__(self, *a, **b): #a接收多个参数, b接收多个键值对
                    self.a =a
                    print("收到")            
            ```

         2. ```
            f = Foo(5)   #out 收到
            ```

      2. attrs参数没有`'__init__': <function Foo.__init__ at 0x0000000004E0DC18>`

         1. ```
            class UpperAttrMetaClass(type): 
                def __new__(cls, class_name, class_parents, attrs):
                    new_attr = {}
                    for name, value in  attrs.items():
                        print('Found mapping: %s ==> %s' % (name, value))
                        if not name.startswith("__"):
                            new_attr[name] = value
                    print("attrs", attrs)
                    print("new_attr", new_attr)           
                    return type.__new__(cls, class_name, class_parents, new_attr)
                    #new_attr没有__init__项, 子类不能带参数初始化
                    
            
            class Foo(metaclass=UpperAttrMetaClass):
                bar = 5
                def __init__(self, *a, **b):  #a接收多个参数, b接收多个键值对
                    self.a =a
                    print("收到") 
            ```

         2. #`f = Foo(5) `   #报错

         

   5. 元类 非常简单, 元类的作用：

      1. 拦截 类的创建
      2. 修改 类
      3. 返回 修改之后的类

5. 为什么要用元类

   1. 元类是深度的魔法
   2. 根本就用不上它

   

6. `__new__`,  `__init__`,  `__call__`

   1. `__new__`
      1. `__new__ ` 在 `__init__` 前被调用的特殊方法
      2. `__new__` 创建类对象,申请对象的内存空间, 并返回之的方法
      3. 很少用到`__new__`，除非要控制对象的创建
      4. 创建类，还要自定义它，就要改写`__new__`
   2. `__init__`
      1. `__init__` 将传入的 参数初始化 给对象
      2. 可以在`__init__`中做些事情
   3. 一些高级的用法会涉及到改写`__call__`特殊方法

补充:

##### 类方法, 实例方法 ,静态方法

1. 定义类 

   1. ```
      class Apple(object):
      	#实例方法有self参数
      	def get_apple(self, n):
      		print("obj_method: %s,%s" % (self, n))
      	#类方法有cls参数	
      	@classmethod
      	def get_class_apple(cls, n):
      		print("cls_method: %s,%s" % (cls,n))
      	#静态方法没有cls, self
      	@staticmethod
      	def get_static_apple(n):
      		#print("static_m:%s,%s" % (cls,n))  #出现cls,报错
      		print("static_m:%s" % (n))
      ```

2. 实例方法

   1. ```
      #实例对象 调用 实例方法
      a = Apple()
      a.get_apple(1) #obj_method: <__main__.Apple object at 0x0000000003287820>,1
      ```

   2. ```
      #类调用 实例方法
      Apple.get_apple(2) #报错, TypeError: get_apple() missing 1 required positional argument: 'n'
      ```

3. 类方法

   1. ```
      #实例对象 调用 类方法
      a = Apple()
      a.get_class_apple(3)  #cls_method: <class '__main__.Apple'>,3
      Apple.get_class_apple(4)  #cls_method: <class '__main__.Apple'>,4
      ```

4. 静态方法

   1. ```
      #实例对象 调用 类方法
      a = Apple()
      a.get_static_apple(5)  #static_m:5
      Apple.get_static_apple(6)  #static_m:6
      ```

5. 结论

   1. 实例方法, 只实例对象可以调用, 类调用 报错
   2. 类方法, 实例对象, 类都可 调用,输出没有 区别
   3. 静态方法, 实例对象, 类 都可调用, 输出没有 区别

#### 22.2 实现ORM

1. ORM是什么

   1. ORM

      1. Django的核心思想 -- `对象-关系-映射`，简称ORM

         1. Django : python编程语言 后端web框架 
         2. `Object Relational Mapping`

      2. 创建一个类，它的 `类名` 作 数据表名，它的 `类属性` 作数据表的 `字段`，操作 实例一样操作MySQL语句

         1. 类的每个实例对象 是 一条记录
         2. 类名 作 表名
         3. 属性 做 字段
         4. 操作 实例 对应 一条MySQL语句

      3. 实例

         1. 定义类

            ```
            class User(父类省略):
                uid = ('uid', "int unsigned")
                name = ('username', "varchar(30)")
                email = ('email', "varchar(30)")
                password = ('password', "varchar(30)")
                ...省略...
            ```

         2. User表 (数据表), 对应 类User

            | uid  | name | email | password |
            | ---- | ---- | ----- | -------- |
            |      |      |       |          |
            |      |      |       |          |
            |      |      |       |          |

            

         3. 操作 实例对象 对应 MySQL语句

            ```
            #类User创建 实例u
            u = User(uid=12345, name='Michael', email='test@orm.org', password='my-pwd')
            u.save()
            --------------
            # 对应如下sql语句
            insert into User (username,email,password,uid)
            values ('Michael','test@orm.org','my-pwd',12345)
            ```

   2. ORM的目的: 

      1. 开发者 操作数据库, 像操作对象一样 : `xxxx.属性=yyyy`
      2. ORM的实现 复杂，Django 已实现了 复杂的操作

2. 元类 实现ORM的 insert功能

   1. 定义元类

      1. ```
         #定义元类
         class ModelMetaclass(type):  #元类的父类是type
             def __new__(cls, name, bases, attrs):
             	
             	#attrs的键值转为mappings的键值
                 mappings = dict()
                 # 判断是否需要保存
                 for k, v in attrs.items():
                     # 判断是否是指定的StringField或者IntegerField的实例对象
                     if isinstance(v, tuple):
                     	#打印键与值
                         print('Found mapping: %s ==> %s' % (k, v))
                         #attrs字典的键值对存入mappings字典
                         mappings[k] = v
         
                 #清空attrs字典 (删除这些已经在字典中存储的属性)
                 for k in mappings.keys():
                     attrs.pop(k)
         
                 #将uid/name/email/password及对应值作 __mappings__ 键的值
                 #attrs放入新的 键值对(键 __mappings__, 键 __table__)
                 attrs['__mappings__'] = mappings  #mappings是属性和值的映射(字典)
                 attrs['__table__'] = name  #name是表名, 表名和类名一致
                 
                 #type.__new__ 创建 类对象
                 return type.__new__(cls, name, bases, attrs) #返回type创建的类对象
         ```

         1. `type.__new__(cls, name, bases, attrs)`中的 参数attrs中必须有`'__init__': <function Foo.__init__ at 0x000000000502BB88>` 项才可以带参数初始化.
         2. 没有`type.__new__`语句, 也不能带参数初始化

   2. 指定元类,创建类

      1. ```
         #指定类User的元类 metaclass=ModelMetaclass
         
         class User(metaclass=ModelMetaclass):
             uid = ('uid', "int unsigned")
             name = ('username', "varchar(30)")
             email = ('email', "varchar(30)")
             password = ('password', "varchar(30)")
             
             '''
             指定元类后，类User的属性放入字典 __mappings__ 中,不放在元类中.
             字典的 键值对:
             __mappings__ = {
                 "uid": ('uid', "int unsigned")
                 "name": ('username', "varchar(30)")
                 "email": ('email', "varchar(30)")
                 "password": ('password', "varchar(30)")
             }
             __table__ = "User"
             '''
             
             def __init__(self, **kwargs):
                 for name, value in kwargs.items():  #分别取出键序列,值序列
                 	#setattr()把类属性设置为实例属性
                     setattr(self, name, value)  #设置self的属性
         	
         	#sql语句封装到函数中, 实现像 对象操作 一样执行 数据库操作
             def save(self):
                 fields = []
                 args = []
                 for k, v in self.__mappings__.items():
                     fields.append(v[0])  #添加值
                     args.append(getattr(self, k, None))  #获取self的属性k
         
                 sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join([str(i) for i in args]))
                 print('SQL: %s' % sql)
         ```

   3. 实现类实例

      1. ```
         #实现像操作对象一样操作 SQL数据库, 如 对象.方法, 对象.属性
         u = User(uid=12345, name='Michael', email='test@orm.org', password='my-pwd')
         # print(u.__dict__)
         u.save()
         ```

   4. 执行结果

      1. ```
         Found mapping: password ==> ('password', 'varchar(30)')
         Found mapping: email ==> ('email', 'varchar(30)')
         Found mapping: uid ==> ('uid', 'int unsigned')
         Found mapping: name ==> ('username', 'varchar(30)')
         SQL: insert into User (uid,password,username,email) values (12345,my-pwd,Michael,test@orm.org)
         ```

3. 小结: 元类, 元类的子类

   1. 示例

      1. 建元类

         1. ```
            class B(type):  
                a = 1
                print(11)
                
                def __new__(cls, name, bases, attrs): #必须写四个参数
                    print(13)
                    print(1, cls)
                    print(2, name)
                    print(3, bases)
                    print(4, attrs)        
            
                def __init__(cls, a1, s2, a3, **kwargs):
                    print(14)
                    self.b1 = b1
                    self.b2 = b2
                    
                def b(a):
                    print(14)
                print(12)
            ```

         2. 执行创建元类对象, 输出

            1. ```
               11
               12
               ```

            2. `__new__`,  `__init__`,  `b` 函数不执行

      2. 用元类创建类

         1. ```
            #指定类User的元类 metaclass=B
            class User(metaclass=B):
                print(21)
                uid = ('uid', "int unsigned")
                name = ('username', "varchar(30)")
               
                print(22)
                def __init__(self, **kwargs):
                    print(25)
                    for name, value in kwargs.items():  #分别取出键序列,值序列
                        setattr(self, name, value)  #设置self的属性
                print(23)
                #sql语句封装到函数中, 实现像 对象操作 一样执行 数据库操作
                def save(self):
                    fields = []
                    args = []
                    print(26)
                print(24)
            ```

         2. 执行创建类对象, 输出:

            1. ```
               21  #类自身创建的
               22
               23
               24
               13   #从此向下是元类的__new__方法执行的结果
               1 <class '__main__.B'>
               2 User
               3 ()
               4 {'__module__': '__main__', '__qualname__': 'User', 'uid': ('uid', 'int unsigned'), 'name': ('username', 'varchar(30)'), '__init__': <function User.__init__ at 0x0000000005025D38>, 'save': <function User.save at 0x0000000005025438>}
               ```

            2. 类内的25, 26没有输出, 子类的`__init__`, `b` 方法不执行

                  

      3. 小结

         1. 遇到类定义, 立即在内存中生成类对象, 属性对象, 函数对象, 但不执行任何方法

            1. 类对象, 属性对象, 函数对象的 id()都是不同的
            2. 函数内的局部变量不能看到

         2. 元类的父类 type

            1. 不继承, 不能用 `type.__new__(cls, name, bases, attrs)`, 此时 子类不能带参数实例化, 但可以不带参数实例化
            2. 继承时, 可以用

         3. 元类的`__new__` 方法:

            1. 作用: metaclaa调用元类时, 创建类对象
               1. 要求元类有`__new__`方法.  若元类没有`__new__`时, 将调用 元类的父类 type的`__new__`方法. 
               2. 没有`__new__`, 子类的属性没法创建
            2. 有4个实参: `cls, name, bases, attrs`,
               1.  第一个参数必须cls, 指向类对象自己
               2. 其他三个参数是mateclass传递过来的

         4. 元类的`__init__` 

            1. 有4个实参: `cls, name, bases, attrs`, 第一个参数必须cls
            2. 可以不写`__init__`
            3. 或`__init__(cls, *args, **kwargs)` 接收实参

         5. 遇到子类定义, 先创建子类对象,  再通过 mateclass 引用元类, 并执行元类的`__new__`方法

            1. mateclass 把子类的属性, 方法引用封装成字典结构放入第4个参数attrs中
            2. mateclass 引用元类, 并向元类传递三个参数
            3. 元类的其他方法不执行

         6. 子类 一般不写`__new__`方法

         7. 子类的要求有`__init__`方法

            1. 参数: 第一个参数, 必须是self
            2. 至少有1个参数, 没规定是4个
            3. 子类可以没有`__init__`,  即默认不带参数的初始化

         8. 若子类没有 metaclass 参数, 则没有元类

               

4. 对数据类型的检测  -- 示例 --

   1. 参数attrs被封装为新的attrs, 新attrs传给`type.__new__`

      1. 此时: 子类的属性方法经`type.__new__`处理后即不属于子类,也不属于子类的实例

      2. 定义元类:  

         1. ```
            #定义一个元类
            class ModelMetaclass(type):
                def __new__(cls, name, bases, attrs):
                    mappings = dict()
                    # 判断是否需要保存
                    for k, v in attrs.items():
                        # 判断是否是指定的StringField或者IntegerField的实例对象
                        if isinstance(v, tuple):
                            print('Found mapping: %s ==> %s' % (k, v))
                            mappings[k] = v
            
                    # 删除这些已经在字典中存储的属性
                    for k in mappings.keys():
                        attrs.pop(k)
            
                    # 将之前的uid/name/email/password以及对应值作为字典的__mappings__键的值
                    #在attrs字典中存入新的 键值对(键`__mappings__`,`__table__`)
                    attrs['__mappings__'] = mappings  # 保存 属性和列 的映射关系
                    attrs['__table__'] = name  #  表名和类名一致
                    return type.__new__(cls, name, bases, attrs)
            ```

            1. `__new__` 方法的参数attrs 被方法处理后封装到新 attrs 中, 子类的属性方法经`type.__new__`处理后即不属于子类,也不属于子类的实例

      3. 指定元类,创建类

         1. ```
            #metaclass把User的属性与方法封装为dict类型传给元类ModelMetaclass的__new__方法的attrs参数
            
            class User(metaclass=ModelMetaclass):
                uid = ('uid', "int unsigned")
                name = ('username', "varchar(30)")
                email = ('email', "varchar(30)")
                password = ('password', "varchar(30)")
            
                '''
                指定元类后，元类经算法处理把类User的属性放在attrs的__mappings__键中.
                字典的 键值对:
                __mappings__ = {
                    "uid": ('uid', "int unsigned")
                    "name": ('username', "varchar(30)")
                    "email": ('email', "varchar(30)")
                    "password": ('password', "varchar(30)")
                }
                __table__ = "User"
                '''
            	
            	#子类的__init__参数至少一个self
                def __init__(self,*args, **kwargs):
                    for name, value in kwargs.items():
                        setattr(self, name, value)
            
                def save(self):
                    fields = []
                    args = []
                    #__mappings__ 元类中定义的, 子类可以用
                    for k, v in self.__mappings__.items():
                        fields.append(v[0])
                        args.append(getattr(self, k, None))
            
                    args_temp = list()
                    for temp in args:
                        # 数据类型判断, 若数字类型
                        if isinstance(temp, int):
                            args_temp.append(str(temp))
                        elif isinstance(temp, str):
                            args_temp.append("""'%s'""" % temp)
                    
                    #__table__ 元类中定义的, 子类可以用
                    sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(args_temp))
                    print('SQL: %s' % sql)
            ```

            1. 实例方法 save(self) 用 `self.__mappings__.items()`,  `self.__table__` 取 attrs字典中的键值对.

      4. 实现类实例

         1. ```
            #实现像操作对象一样操作 SQL数据库, 如 对象.方法, 对象.属性
            u = User(uid=12345, name='Michael', email='test@orm.org', password='my-pwd')
            # print(u.__dict__)  #查看实例u的字典属性
            u.save()
            ```

         2. 执行结果

            1. ```
               Found mapping: uid ==> ('uid', 'int unsigned')
               Found mapping: password ==> ('password', 'varchar(30)')
               Found mapping: name ==> ('username', 'varchar(30)')
               Found mapping: email ==> ('email', 'varchar(30)')
               SQL: insert into User (email,uid,password,username) values ('test@orm.org',12345,'my-pwd','Michael')
               ```

            

         3. ```
            u = User(1, 3, 4)
            User.uid  #AttributeError: type object 'User' has no attribute 'uid'
            u.uid  #AttributeError: 'User' object has no attribute 'uid'
            ```

   2. 参数attrs未改变, 直接传给`type.__new__`

      1. 定义元类

         1. ```
            #定义一个元类
            class ModelMetaclass(type):
                def __new__(cls, name, bases, attrs):
            
                    return type.__new__(cls, name, bases, attrs)
            ```

      2. 用指定元类定义子类

         1. ```
            class User(metaclass=ModelMetaclass):
                uid = ('uid', "int unsigned")
                name = ('username', "varchar(30)")
                email = ('email', "varchar(30)")
                password = ('password', "varchar(30)")
            
                def __init__(self,*args, **kwargs):
                    for name, value in kwargs.items():
                        setattr(self, name, value)
            
            
                def save(self):
                    fields = []
                    args = []
                    for k, v in self.__mappings__.items():
                        fields.append(v[0])
                        args.append(getattr(self, k, None))
            
                    args_temp = list()
                    for temp in args:
                        # 数据类型判断, 若数字类型
                        if isinstance(temp, int):
                            args_temp.append(str(temp))
                        elif isinstance(temp, str):
                            args_temp.append("""'%s'""" % temp)
                    sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(args_temp))
                    print('SQL: %s' % sql)
            ```

      3. 实例类实例

         1. ```
            u = User(1, 3, 4)
            ```

         2. `User.uid`   #[out]  ('uid', 'int unsigned')

         3. `u.uid`   #[out]  ('uid', 'int unsigned')

   

5. 属性放到子类 -- 示例

   1. 创建元类

      1. ```
         class ModelMetaclass(type):
             def __new__(cls, name, bases, attrs):
                 mappings = dict()
                 # 判断是否需要保存
                 for k, v in attrs.items():
                     # 判断是否是指定的StringField或 IntegerField的实例对象
                     if isinstance(v, tuple):
                         print('Found mapping: %s ==> %s' % (k, v))
                         #attrs的items转存到mappings中
                         mappings[k] = v
         
                 # 删除这些已经在字典中存储的属性
                 for k in mappings.keys():
                     attrs.pop(k)
         
                 # 将之前的uid/name/email/password以及对应的对象引用、类名字
                 attrs['__mappings__'] = mappings  # 保存属性和列的映射关系
                 attrs['__table__'] = name  # 假设表名和类名一致
                 return type.__new__(cls, name, bases, attrs)
         ```

   2. 指定元类, 创建父类

      1. ```
         class Model(object, metaclass=ModelMetaclass):
             def __init__(self, **kwargs):
                 for name, value in kwargs.items():
                 	#动态设置实例的属性
                     setattr(self, name, value)
         
             def save(self):
                 fields = []  #储存表的字典
                 args = []   #存储表的字段值
                 for k, v in self.__mappings__.items():
                     fields.append(v[0])
                     args.append(getattr(self, k, None))
         
                 args_temp = list()
                 for temp in args:
                     # 判断入如果是数字类型
                     if isinstance(temp, int):
                         args_temp.append(str(temp))
                     elif isinstance(temp, str):
                         args_temp.append("""'%s'""" % temp)
                 sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(args_temp))
                 print('SQL: %s' % sql)
         ```

   3. 指定父类, 创建只含属性的类

      1. ```
         class User(Model):
             uid = ('uid', "int unsigned")
             name = ('username', "varchar(30)")
             email = ('email', "varchar(30)")
             password = ('password', "varchar(30)")
         ```

   4. 实现类实例

      1. ```
         u = User(uid=12345, name='Michael', email='test@orm.org', password='my-pwd')
         # print(u.__dict__)
         u.save()
         ```

   5. 小结

      1. User 继承自 Mode, Model 继承自 元类ModelMetaclass.
         1. ModelMetaclass的`__new__`处理了传入的参数, 并返回`type.__new__`创建的类对象
      2. ModelMetaclass元类的`__new__`方法处理了传给参数attrs的实参
         1.  name, email, password 同 uid
      3. User类初始化
         1. 先看自身的 `__init__`, 
            1. 如果有, 再看参数合适吧. 合适 则创建对象, 不合适 则报错
         2. 自身没有, 看父类的 `__init__`
            1. 如果有, 再看参数合适吧. 合适 则创建对象, 不合适 则报错
         3. 依次循环
         4. 如果都没有, 则用默认的 无参数 `__init__`方法初始化.





-------------------

#### 06-元类

###### 视频版本

##### 01-类也是对象、globals查看所有的全局对象引用

1. sqlite

   1.  关系型数据库,
   2.  可以用sql语句
   3.  不需要服务器的数据库

2. mysql

   1.  分服务器端, 和客户端 两类
   2.  需要服务器

3. `globals()`

   1. python内置函数

   2. 返回值: 一个字典, 程序运行时的所有全局变量

   3. 在这个内存空间中有名字, 则可以了被用

      

##### 02-元类创建类，类创建实例对象

1. 元类-->类-->实例对象

   1. 元类: 继承 type类, 生成类的类. 返回值是个类

      ````
      #继承了type类, 就是元类, 可以没有__new__, 或__new__中没有 type.__new__(cls, name, bases, attrs)
      class A(type):   
      	pass
      ````

      A 是元类,    

2. type()方式构造 类 

   ```
   #type("name", bases, attrs)
   类名 = type("类的名字", (继承父类名元组), {字典})
   
   Test = type("Test1",(), {"name":'jj'})  # 创建Test类, Test变量名, Test1是内存中的名
   Test1 = type("Test1",(), {"name":'jj'})  # 左右 相同 最好
   ```

   type是Python的内建元类, type本身是元类

##### 03-type创建类，元类应用demo

1. type创建 类流程

   1. 创建类内的方法

      1. ```
         class A(object):
         	num = 0
         	
         def print_normal(self):
         	print("--normal--")
         	
         @classmethod
         def print_class(cls):
         	print("--class--")
         
         @staticmethod
         def print_static():
         	print("--static--")
         ```

   2. type创建新类

      1. ```
         New_class = type("New_class", (A,),{"print_normal": print_normal, "print_class": print_class, "print_static": print_static})
         ```

   3. 小结

      1. 方法原型 外部定义,  字典值引用. 字典的键是字符串, 值是函数名引用
       2. New_class  是普通类, 不是元类

2. 魔法属性

   1.    `__class__ `  , 对象的类  (类的父类,实例的类), 自动继承的, 不用显式出现
   2. 魔法属性是对类或实例的一些数据的描述整合

3. 用函数作元类 (思路引导, 工作不用)

   1. 创建元类: 

      1. ```
         #-*- coding:utf-8 -*-
         #函数作元类 (思路引导, 工作不用)
         def upper_attr(class_name, class_parents, class_attr):
            #遍历属性字典，把不是__开头的属性名字变为大写
            new_attr = {}
            for name,value in class_attr.items():
                if not name.startswith("__"):
                    new_attr[name.upper()] = value
            
            #调用type来创建一个类
            return type(class_name, class_parents, new_attr)
         ```

   2. 创建类, python3中

      1. ```
         class Foo(object, metaclass=upper_attr):  # metaclass指定元类
         	bar = 'bip'
         ```

   3. 创建类, python2中

      1. ```
         class Foo(object):
            	__metaclass__ = upper_attr   #指定元类
            	bar = 'bip'
         ```

   4. 判断属性

      1. `hasattr(Foo, 'bar')`

4. 小结

   1. python2中, `__metaclass__` 魔法属性, 指定元类 
   2. python3中, metaclass 指定元类

##### 04-元类应用demo-补充

1. 元类, 生成类的类,  对已定义的类进行**修改或添加**功能

2. 装饰器, 对函数进行进行修改或添加功能

3. `__new__,  __init__`

   1. `__new__`
      1. 创建类对象, 并返回之的方法, 不是实例对象
      2. 在 `__init__` 之前被调用的特殊方法
   2. `__init__ ` 用传入的参数初始化给对象

4. 示例

   1. 定义元类

      1. ```
         #coding=utf-8
         class UpperAttrMetaClass(type):
         	def __new__(cls, class_name, class_parents, class_attr):
         		#cls,class_name类名,class_parents父类名,class_attr类属性
         		#遍历属性字典，把不是__开头的属性名字变为大写
         		new_attr = {}
         		
         		for name, value in class_attr.items():
         			if not name.startswith("__"):
         			new_attr[name.upper()] = value
         
         		#方法1：type 创建类对象
         		#return type(class_name, class_parents, new_attr)
         
         		#方法2：type.__new__ 创建类对象, 基本的OOP编程，没魔法
         		return type.__new__(cls, class_name, class_parents, new_attr)
         ```

         1. `__new__`  创建类对象
            2. `type.__new__`的 new_attr 没有 `__init__`键值对, 子类Foo不能带参数初始化 

      2. python3 元类创建类:

            1. ```
               class Foo(object, metaclass=UpperAttrMetaClass):
               	bar = 'bip'
               ```

   3. python2 元类 创建类:

      1. ```
         class Foo(object):
            __metaclass__ = UpperAttrMetaClass
            bar = 'bip'
         ```

   4. 判断类属性

      1. ```
         print(hasattr(Foo, 'bar'))   #输出: False
         print(hasattr(Foo, 'BAR'))  #输出:True
         ```

      2. ```
         f = Foo()
         print(f.BAR)  #输出:'bip'
         ```

5. 小结

   1. 元类 的 父类 type
   2. 元类的返回值: `type(),  或  type.__new__`
   3. 元类 修改或增加其他类的功能

#### 07-orm

##### 01-orm介绍

1. ORM - object relation map, 对象关系映射

2. 示例

   1. ```
      class User():
      	uid = ("uid", "int unsigned")  # 右边是元组
      	name = ("username", "varchar(30)")
      	email = ("email", "varchar(30)")
      	password = ("password", "varchar(30)")
             
             
      u = User(uid=123, name='lw', email='aa@q1.com', password='123')
      u.save()
      ```

      1. uid, name, email, password  类属性
         2. User 类名
         3. 对象.方法,  自动转化为 SQL 语句

      2. ```
         u.save()  #等价于
         insert into User(uid, name, email, password) values(123, 'lw', 'aa@q1.com', '123')
         ```

##### 02-orm-实现

1. 示例

   1. 定义元类

      1. ```
         class ModelMetaclass(type):  # 元类
             def __new__(cls, name, bases, attrs):  # attrs是字典, 保存类属性和值
                 mappings = dict()
                 # 判断, 另保存attrs
                 for k, v in attrs.items():
                     # 判断是是否是指定的StringField或者IntegerField的实例对象
                     if isinstance(v, tuple):
                         print('Found mapping: %s ==> %s' % (k, v))
                         mappings[k] = v   
         
                 # attrs字典已保存, 可以除它的属性, 再存储__mappings__,__table__属性
                 for k in mappings.keys():
                     attrs.pop(k)
         
                 # 将之前的uid/name/email/password以及对应的对象应用, 类名字
                 attrs['__mappings__'] = mappings  # 保存属性和列的映射关系
                 attrs['__table__'] = name  # 假设表名和类名一致
                 return type.__new__(cls, name, bases, attrs)
         ```

         1. `__new__` 的参数 attrs是字典,  {"uid": ('uid', "int unsigned"), "name": ('username', "varchar(30)"), "email": ('email', "varchar(30)"), "password": ('password', "varchar(30)")}, 
            1. 子类的属性和值 封装成字典类型
         2. mappings是字典: {"uid": ('uid', "int unsigned"), "name": ('username', "varchar(30)"), "email": ('email', "varchar(30)"), "password": ('password', "varchar(30)")}
         3. `type.__new__` 中的attrs是字典,  `arrts={__mappings__: {"uid": ('uid', "int unsigned"), "name": ('username', "varchar(30)"), "email": ('email', "varchar(30)"), "password": ('password', "varchar(30)")}, __table__: "User"}`    

   2. 用元类创建类

      1. ```
         class User(metaclass=ModelMetaclass): #用元类创建类
             uid = ('uid', "int unsigned")
             name = ('username',  "varchar(30)")
             email = ('email', "varchar(30)")
             password = ('password', "varchar(30)")
             # 元类把User类的 属性=值 转变为 __mappings__的值, User类名 转变为__table__的值, 
             # 类属性实际的样子:
             # __mappings__ = {
             #   "uid": ('uid', "int unsigned")
             #   "name": ('username', "varchar(30)")
             #   "email": ('email', "varchar(30)")
             #   "password": ('password', "varchar(30)")
             # }
             # __table__ = "User"
             
             def __init__(self, **kwargs):  # self 实例对象
                 for name, value in kwargs.items():
                     setattr(self, name, value)   # name的值必须是字符串
         
             def save(self):
                 fields = []
                 args = []
                 for k, v in self.__mappings__.items():
                     fields.append(v[0])
                     args.append(getattr(self, k, None))
         
                 sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join([str(i) for i in args]))
                 print('SQL: %s' % sql)
         ```

         1. metaclass 把类 User 的属性方法封装成字典, 并传给指定的元类的`__new__`方法的attrs参数

   3. 类User初始化

      1. ```
         u = User(uid=12345, name='Michael', email='test@orm.org', password='my-pwd')
         # print(u.__dict__)
         u.save()
         ```

   4. python解释器遇到类定义, 理解内存空间申请

      1. ```
         # 元类的 类属性:
         ModelMetaclass.__dict__: 
         mappingproxy({'__module__': '__main__', 
         '__new__': <staticmethod object at 0x00000000039048E0>, 
         '__doc__': None})
         ```

      2. ```
         # 生成类的 类属性: 
         User.__dict__:
         mappingproxy({'__module__': '__main__', 
         '__init__': <function User.__init__ at 0x000000000391CEE0>, 
         'save': <function User.save at 0x0000000003930EE0>, 
         '__mappings__': {'uid': ('uid', 'int unsigned'), 'name': ('username', 'varchar(30)'), 'email': ('email', 'varchar(30)'), 'password': ('password', 'varchar(30)')}, '__table__': 'User', 
         '__dict__': <attribute '__dict__' of 'User' objects>, 
         '__weakref__': <attribute '__weakref__' of 'User' objects>, 
         '__doc__': None})
         ```

      3. ```
         # 实例化后 u = User(uid=12345, name='Michael', email='test@orm.org', password='my-pwd')
         u.__dict__: 
         {'uid': 12345, 'name': 'Michael', 'email': 'test@orm.org', 'password': 'my-pwd'}
         ```

      4. id(ModelMetaclass): 50361712,  id(User): 50362656, id(u): 59947136, 即**内存地址**不同

2. 小结

   1. python内置的反射函数:  setattr(), getattr()

      1. setattr(object, name, value) 

         1. 参数
            object -- 对象。
            name -- 字符串，对象属性。
            value -- 属性值。

      2. ```
         >>>class A(object):
         ...     bar = 1
         ... 
         >>> a = A()
         >>> getattr(a, 'bar')          # 获取属性 bar 值
         1
         >>> setattr(a, 'bar', 5)       # 设置属性 bar 值
         >>> a.bar
         5
         ```

      

##### 03-orm-实现2

1. 元类在orm中的应用: 元类创建类的类

2. 示例

   1. 定义元类

      1. ```
         class ModelMetaclass(type):
             def __new__(cls, name, bases, attrs):
                 mappings = dict()
                 # 判断是否需要保存
                 for k, v in attrs.items():
                     # 判断是否是指定的StringField或者IntegerField的实例对象
                     if isinstance(v, tuple):
                         print('Found mapping: %s ==> %s' % (k, v))
                         mappings[k] = v
         
                 # 删除这些已经在字典中存储的属性
                 for k in mappings.keys():
                     attrs.pop(k)
         
                 # 将之前的uid/name/email/password以及对应的对象引用, 类名字
                 attrs['__mappings__'] = mappings  # 保存属性和列的映射关系
                 attrs['__table__'] = name  # 假设表名和类名一致
                 return type.__new__(cls, name, bases, attrs)
         ```

   2.  指定元类, 创建父类

       1.  ```
           class Model(object, metaclass=ModelMetaclass):
               def __init__(self, **kwargs):
                   for name, value in kwargs.items():
                       setattr(self, name, value)
           
               def save(self):
                   fields = []
                   args = []
                   for k, v in self.__mappings__.items():
                       fields.append(v[0])
                       args.append(getattr(self, k, None))
           
                   args_temp = list()
                   for temp in args:
                       # 判断输入如果是数字类型
                       if isinstance(temp, int):
                           args_temp.append(str(temp))
                       elif isinstance(temp, str):
                           args_temp.append("""'%s'""" % temp)
                   sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(args_temp))
                   print('SQL: %s ' % sql)
           ```

   3.  创建类(属性抽取后放一个类中)

       1.  ```
           class User(Model):
           	#属性时tuple类型
               uid = ('uid', "int unsigned")
               name = ('username', "varchar(30)")
               email = ('email', "varchar(30)")
               password = ('password', "varchar(30)")
           ```

   4.  实例化

       1.  ```
           u = User(uid=12345, name='Michael', email='test@orm.org', password='my-pwd')
           # print(u.__dict__)
           u.save()
           ```

       2.  ```
           ModelMetaclass.__class__  # <class 'type'>
           Model.__class__         # <class '__main__.ModelMetaclass'>
           User.__class__          # <class '__main__.ModelMetaclass'>
           u.__class__             # <class '__main__.User'>
           ```

3.  魔法方法

    1.  建类

        1.  ```
            class A(object):
                """
                Class A.
                """
            
                a1 = 11
                a2 = 12
            
                def __init__(self):
                    self.a3= 13
                    self.a4 = 14
                def test(self):
                    print( 'a normal func.')
                @staticmethod
                def static_test(self):
                    print( 'a static func.')
                @classmethod
                def class_test(self):
                    print ('a calss func.')
                    
            #子类
            class B(A):
                """
                Class B.
                """
            
                b1 = 20
                b2 = 22
            
                def __init__(self):
                    self.b3 = 23
                    self.b4 = 24
                def test(self):
                    print( 'b normal func.')
                @staticmethod
                def static_test(self):
                    print( 'b static func.')
                @classmethod
                def class_test(self):
                    print ('b calss func.')
                    
            #子类
            class C(B):
                """
                Class C.
                """
            
                c1 = 11
                c2 = 12
            
                def __init__(self):
                    self.c3= 13
                    self.c4 = 14
                def test(self):
                    print( 'c normal func.')
                @staticmethod
                def static_test(self):
                    print( 'c static func.')
                @classmethod
                def class_test(self):
                    print ('c calss func.')
                    
                    
            c = C()
            C.__dict__  #类中的属性 类中方法的 字典, 不含实例的属性, 不含父类的属性方法
            #实例的自己的属性字典, 不含类的属性和方法
            c.__dict__ #{'c3': 13, 'c4': 14}
            
            #C的所有类
            C.mro()  #[__main__.C, __main__.B, __main__.A, object]
            c.mor()  #AttributeError: 'C' object has no attribute 'mro'
            
            #基类
            C.__bases__   #(__main__.B,)
            c.__bases__   #AttributeError: 'C' object has no attribute '__bases__'
            
            #查看对象的直接类
            C.__class__  #type
            c.__class__  #__main__.C
            
            C.__doc__    #'\n    Class C.\n    '
            C.__doct__   #'\n    Class C.\n    '
            ```

    2.  小结

        1.  `__class__`功能,  查看对象的直接类, 功能和type()函数一样
            1.  `类名.__class__`,  `实例名.__class__`
        2.  mro(), 类的所有类, 包括自己
            1.  `类名.mro()`
        3.  `类名.__bases__`, 类的直接父类
        4.  `类名.__dict__`,  类中的属性 类中方法的 字典, 不含实例的属性, 不含父类的属性方法
        5.  `实例名.__dict__` 实例对象的自己的属性字典
        6.  `实例名.__doc__`,  `类名.__doc__`   , 直接类的文档

4.  小结

    1.  魔法方法是从子类向上寻找.
        1.  如`__new__`, 先看看自己有没有, 再看看父类有没有, 再看看元类有没有
        2.  都没有就用默认的
    2.  普通方法是继承.

    

##### 04-python高级知识快速复习-1

python高级

Linux介绍、命令---------------->会用就行，多练
	操作系统（科普章节）
	操作系统的发展史（科普章节）
	文件和目录
	Ubuntu 图形界面入门
	Linux 命令的基本使用
	Linux 终端命令格式
	Linux 常用命令(一)
	Linux 常用命令(二)
	ls cd pwd rm cat cp mv mkdir touch tree more top htop ps kill clear history ifconfig ping ssh scp tar 
	chmod shutdown reboot find grep ln sudo man which who whoami >重定向输出 |管道

Linux安装软件、python开发环境
	软件安装与卸载
	常用服务器ftp、ssh
	编辑器vim
	pycharm的集成vim
	编辑器sublime、终端运行python

网络-udp---------------->了解
	网络通信概述
	ip地址(重点)
	Linux命令(ping、ifconfig等)
	端口(重点)---------------->重点
	socket简介
	udp网络程序-发送、接收数据(重点)
	python3编码转换
	udp绑定端口问题(重点)
	网络通信过程(简单版)
	案例:udp聊天器

网络-tcp
	tcp简介
	tcp网络程序-客户端(重点)
	tcp网络程序-服务器(重点)
	tcp注意点(重点)
	案例:文件下载器
	tcp的3次握手(重点)---------------->重点
	tcp的4次挥手(重点)---------------->重点
	tcp长连接和短连接---------------->重点
	wireshark的使用---------------->要会用
	tcp/ip简介

多任务-线程---------------->重点：进程、线程、协程 的区别，互斥锁，GIL
	多任务的介绍
	多任务的概念
	线程(重点)
	线程-注意点
	多线程-共享全局变量(重点)
	多线程-共享全局变量-问题
	同步
	互斥锁(重点)  : 逻辑上保证这个事情完成, 逻辑上保证A任务完成后B任务才开始

​	GIL : 全局锁, 同一时刻 只有一个线程在运行	

​	死锁
​	案例:多任务版udp聊天器

多任务-进程
	进程以及状态
	进程的创建-multiprocessing
	进程、线程对比
	进程间通信-Queue
	进程的创建-进程池Pool
	案例：文件夹copy器（多进程版）

多任务-协程
	迭代器
	生成器
	协程-yield
	协程-greenlet
	协程-gevent
	进程、线程、协程区别
	案例:并发下载器

正则表达式---------------->重点
	正则表达式概述
	re模块操作
	匹配单个字符
	匹配多个字符
	匹配开头结尾
	匹配分组
	re模块的高级用法
	贪婪和非贪婪
	r的作用   re.find(r'', "")

##### 05-python高级知识快速复习-2

http协议、web服务器-并发服务器1---------------->重点：HTTP协议, 访问baidu.com的过程， 浏览器和服务器之间的交互. (输入域名, 域名解析,3次握手, 传数据, 4次挥手)
	http协议
	Web静态服务器-1-显示固定的页面
	Web静态服务器-2-显示需要的页面
	Web静态服务器-3-多进程
	Web静态服务器-4-多线程

web服务器-并发服务器2
	Web静态服务器-5-非堵塞模式
	Web静态服务器-6-epoll
	Web静态服务器-7-gevent版
	知识扩展-C10K问题

网络通信过程
	网络通信过程
	NAT

python提高-1
	GIL---------------->重点
	深拷贝、浅拷贝---------------->重点
	私有化
	import导入模块
	再议 封装、继承、多态---------------->重点
	
python提高-2
	多继承以及MRO顺序---------------->重点
	再议静态方法、类方法
	property属性-讲解
	property属性-应用
	魔法属性
	面向对象设计
	with与“上下文管理器”---------------->重点

MySQL-基本使用
	数据库简介
		数据存储
		数据库
		RDBMS
		RDBMS和数据库的关系
		SQL
		MySQL
	MySQL安装
	数据完整性
	Navicat图形界面工具操作
		数据库操作
		数据表操作
		数据操作
	命令行脚本(重点)---------------->重点
		数据库操作
		数据表操作
		数据增删改查
		数据备份&恢复
	数据库的设计

MySQL-查询---------------->重点
	MySQL查询
	条件
	排序
	聚合函数
	分组
	分页
	连接查询
	自关联
	子查询
	总结


MySQL与Python交互
	准备数据
	SQL演练
	数据库设计
	Python操作MySQL步骤
	增删改查
	参数化

MySQL高级---------------->重点
	视图: 虚拟的表
	事务 ACID
		提交
		回滚
	索引 : 特殊的数据结构, 方便查询
	账户管理(了解)
		授予权限
		账户操作
	MySQL主从

WSGI、mini-web框架---------------->重点：WSGI : web服务器与框架的数据协议, 解耦
	服务器动态资源请求
	应用程序示例
	Web动态服务器-基本实现
	mini-web框架-1-文件结构
	mini-web框架-2-显示页面
	mini-web框架-3-替换模板

闭包、装饰器---------------->重点重点重点重点
	闭包
	装饰器

mini-web框架 添加路由、MySQL功能
	mini-web框架-4-路由
	伪静态、静态和动态的区别
	mini-web框架-5-实现伪静态url
	准备股票数据
	mini-web框架-6-从mysql中查询数据
	mini-web框架-7-组装数据为html格式

mini-web框架 添加log日志、路由支持正则
	mini-web框架-8-路由支持正则
	mini-web框架-9-mysql增
	mini-web框架-10-mysql删
	mini-web框架-11-mysql改
	mini-web框架-12-url编码
	logging日志模块

元类、实现ORM---------------->当需要提高的时候，可以看看
	元类
	元类实现ORM

<<生如夏花>>

花上时间不断重复, 重点的静下心多看,  该了解走马观花看看就完了

