### 5 多任务-  线程

#### 5.1 多任务介绍

1. 多任务
   1. 唱歌, 跳舞 2 件事 同时进行
   2. 同时进行的方法，叫做：**多任务**

#### 5.2 多任务的概念

1. 多核, 单核
   1. 单核 多任务
      1. 操作系统  任务 交替执行
   2. 多核 CPU 多任务: 真正的 并行
2. 并行, 并发
   1. 并发： 任务数 **多于**  cpu核数，操作系统 通过 调度算法，实现 多个任务“一起”执行（实际上 不 一起执行 ）, 假的
   2. 并行： 任务数**小于等于** cpu核数， 真的 一起执行的

#### 5.3  线程

1. thread, threading

   1. thread模块 底层的模块
   2. threading模块 对thread做 包装的， 方便

2. 多线程执行

   1. ```
      #coding=utf-8
      import threading
      import time
      
      def saySorry():
          print("亲爱的，我错了，我能吃饭了吗？")
          time.sleep(1)
      
      if __name__ == "__main__":
          for i in range(5):
              t = threading.Thread(target=saySorry)
              t.start() #启动线程，即让线程开始执行
      ```

   2. 线程

      1. 多线程并发,  时间 短
      2. 调用`start() `，真正 创建线程，并 开始执行

3. 主线程 等待 子线程结束后才结束

   1. ```
      #coding=utf-8
      import threading
      from time import sleep,ctime
      
      def sing():
          for i in range(3):
              print("正在唱歌...%d"%i)
              sleep(1)
      
      def dance():
          for i in range(3):
              print("正在跳舞...%d"%i)
              sleep(1)
      
      if __name__ == '__main__':
          print('---开始---:%s'%ctime())
      
          t1 = threading.Thread(target=sing)
          t2 = threading.Thread(target=dance)
      
          t1.start()
          t2.start()
      
          #sleep(5) # 屏蔽此行代码，程序等5s再结束
          print('---结束---:%s'%ctime())
      ```

      1.  t1, t2 子线程
      2. 屏蔽sleep(5), 主线程 main 不等子线程结束就结束.

4. threading.enumerate()

   1. 查看线程数量

   2. ```
      #coding=utf-8
      import threading
      from time import sleep,ctime
      
      def sing():
          for i in range(3):
              print("正在唱歌...%d"%i)
              sleep(1)
      
      def dance():
          for i in range(3):
              print("正在跳舞...%d"%i)
              sleep(1)
      
      if __name__ == '__main__':
          print('---开始---:%s'%ctime())
      
          t1 = threading.Thread(target=sing)
          t2 = threading.Thread(target=dance)
      
          t1.start()
          t2.start()
      
          while True:
              length = len(threading.enumerate())
              print('当前运行的线程数为：%d'%length)
              if length<=1:
                  break
      
              sleep(0.5)
      ```

#### 5.4  线程-注意点

1. 线程的封装

   1. 新子类, 继承`threading.Thread `，重写`run`方法

      1. python的threading.Thread类 run方法， 定义线程的功能 
      2. 自定义的线程类中覆盖threading.Thread类run方法。
      3. 创建 线程实例 后，用 Thread类的 `start()` 方法 启动 该线程，交给python虚拟机 调度.
      4. 线程执行, start() 方法 调用 run方法 执行线程

   2. ```
      #coding=utf-8
      import threading
      import time
      
      class MyThread(threading.Thread):
          def run(self):
              for i in range(3):
                  time.sleep(1)
                  msg = "I'm "+self.name+' @ '+str(i) #name属性 是当前线程的名字
                  print(msg)
      
      
      if __name__ == '__main__':
          t = MyThread()
          t.start()
      ```

      1. 执行结果

         1. ```
                I'm Thread-1 @ 0
                I'm Thread-2 @ 0
                I'm Thread-5 @ 0
                I'm Thread-3 @ 0
            ```

            

3. 总结
   1. 每个线程  默认名字，python会自动为线程指定一个名字
      1. self.name
      2. Thread-1, Thread-2, Thread-3, ......, 
   2. **run()**  结束时该线程完成。
   3. 不能 控制  `线程调度程序`， 可用 别的方式 影响线程调度 。

----

#### 5.5 多线程-共享全局变量

1. global

   1. ```
      from threading import Thread
      import time
      
      g_num = 100
      
      def work1():
          global g_num
          for i in range(3):
              g_num += 1
      
          print("----in work1, g_num is %d---"%g_num)
      
      
      def work2():
          global g_num
          print("----in work2, g_num is %d---"%g_num)
      
      
      print("---线程创建之前g_num is %d---"%g_num)
      
      t1 = Thread(target=work1)
      t1.start()
      
      #延时一会，保证t1线程中的事情做完
      time.sleep(1)
      
      t2 = Thread(target=work2)
      t2.start()
      ```

   2. 运行结果

      1. ```
         ---线程创建之前g_num is 100---
         ----in work1, g_num is 103---
         ----in work2, g_num is 103---
         ```
         
      2. 结论: 两个线程共享 global 变量  g_num

2. 列表当 实参 传递到线程中

   1. ```
      from threading import Thread
      import time
      
      def work1(nums):
          nums.append(44)
          print("----in work1---",nums)
      
      
      def work2(nums):
          #延时一会，保证t1线程中的事情做完
          time.sleep(1)
          nums.append(55)
          print("----in work2---",nums)
      
      g_nums = [11,22,33]   # g_nums 线程共享
      
      t1 = Thread(target=work1, args=(g_nums,))
      t1.start()
      
      t2 = Thread(target=work2, args=(g_nums,))
      t2.start()
      time.sleep(3)
      print("----in main----", g_nums)  #主线程
      ```

   2. 运行结果:

      1. ```
         ----in work1--- [11, 22, 33, 44]
         ----in work2--- [11, 22, 33, 44, 55]
         ----in main---- [11, 22, 33, 44, 55]
         ```

      2. 若 子线程没运行完, 输出当前g_nums的值

      3. 若 子线程运行完, 主线程输出执行完的 g_nums的值

3. 总结:

   1. 进程内的 线程 共享全局变量， 方便在多个 线程共享 数据
   2. 缺点
      1. 每个线程都可对 同一个全局变量 可任意改动,
      2.  线程非安全 



#### 5.6 多线程-共享全局变量问题

1. 多线程开发 问题

   1. ```
      import threading
      import time
      
      g_num = 0
      
      def work1(num):
          global g_num
          for i in range(num):
              g_num += 1
          print("----in work1, g_num is %d---"%g_num)
      
      
      def work2(num):
          global g_num
          for i in range(num):
              g_num += 1
          print("----in work2, g_num is %d---"%g_num)
      
      
      print("---线程创建之前g_num is %d---"%g_num)
      
      t1 = threading.Thread(target=work1, args=(1000000,))
      t1.start()
      
      t2 = threading.Thread(target=work2, args=(1000000,))
      t2.start()
      
      while len(threading.enumerate()) != 1:
          time.sleep(1)
      
      print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)
      ```

      1. 结果:

         1. ```
            ---线程创建之前g_num is 0---
            ----in work1, g_num is 1332529---
            ----in work2, g_num is 1368022---
            2个线程对同一个全局变量操作之后的最终结果是:1368022
            ```

      2. g_num 的值是在线程中是公共的

   2. 结论:

      1. 多个线程 对 同一个全局变量 操作， 出现资源竞争 ，  结果 不确定.

#### 5.7 同步的概念

1. 同步
   1. 协同步调，按预定的次序 进行
      1. "同" 指 协同、协助、互相配合
   2. 如:你说完，我再说。
   3. 进程、线程同步
      1. (进程或线程)A和B一块配合
      2. A执行到一定程度时要依靠B的某个结果，于是A停下来， B运行
      3. B执行，再将结果给A, A再继续执行.
2. 解决线程`共享全局变量`  的方式
   1. **线程同步**
   2. 思路:  锁
      1. 系统调用t1， 获取到g_num的值 0，此时 上锁，即不允许其他线程操作g_num
      2. t1对g_num的值进行+1
      3. t1 解锁，此时g_num的值为1，其他的线程用g_num，此时g_num的值是1不是0
      4. 同理, 其他线程对g_num 修改, 要先 上锁，处理完 再解锁. 在上锁的整个过程中不允许其他线程访问， 保证 数据的正确性

#### 5.8 互斥锁

1. 互斥锁
   1. 原因: 多个线程 修改 一个共享数据 时 ，需 同步控制. 
      1.  每次只有一个线程 写入操作， 保证了多线程 数据的正确性
   2. 互斥锁
      1. 为资源引入一个 状态：锁定/非锁定
      2. 上锁解锁  过程
         1.  线程A 调用 `锁对象.acquire()` 时，锁 进入“locked”状态。
         2.   线程A 获得锁。  线程B 试图获得这个锁, 会变为“blocked”状态，称 “阻塞”，直到 线程A 调用`锁对象.release()` 释放锁 ，锁进入“unlocked”状态。
         3. 线程调度程序 从处于同步阻塞状态的线程中选择一个 线程B 获得锁，并使 线程B 进入运行（running）状态。
   
2. threading模块 Lock类 处理锁定

   1. ```
      # 创建锁
      mutex = threading.Lock()
      
      # 锁定
      mutex.acquire()
      
      #被锁定的代码或变量操作
      g_num +=1
      # 释放
   mutex.release()
      ```
      
   1. 之前 没上锁 ， acquire不会堵塞
      
      2.  已 上锁， acquire会堵塞，直到 解锁
      
   2. 互斥锁, 2个线程对同一个全局变量各加100万次

      1. ```
         import threading
         import time
         
         g_num = 0
         
         def test1(num):
             global g_num
             for i in range(num):
                 mutex.acquire()  # 上锁
                 g_num += 1
                 mutex.release()  # 解锁
         
             print("---test1---g_num=%d"%g_num)
         
         def test2(num):
             global g_num
             for i in range(num):
                 mutex.acquire()  # 上锁
                 g_num += 1
                 mutex.release()  # 解锁
         
             print("---test2---g_num=%d"%g_num)
         
         # 创建一个互斥锁
         # 默认是未上锁的状态
         #函数外定义锁对象
         mutex = threading.Lock()  #
         
         # 创建2个线程，让他们各自对g_num加1000000次
         p1 = threading.Thread(target=test1, args=(1000000,))
         p1.start()
         
         p2 = threading.Thread(target=test2, args=(1000000,))
         p2.start()
         
         # 等待计算完成
         while len(threading.enumerate()) != 1:
             time.sleep(1)
         
         print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)
         ```
   ```
         
   2. 运行结果
      
         1. ```
            ---test1---g_num=1909909
            ---test2---g_num=2000000
            
            2个线程对同一个全局变量操作之后的最终结果是:2000000
   ```

3. 锁 总结

   1.  好处 
      1.  `锁定代码`只能由一个线程 完整地执行
   2.  坏处 
      - 效率 下降. 阻止了多线程并发 ，包含锁的某段代码实际上只能以单线程模式执行
      -  死锁. 存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，造成死锁

#### 5.9 死锁

1. 死锁 : 

   1. 两个线程分别占有一部分资源并且同时等待对方的资源， 造成死锁
   2. 后果: 应用的停止响应

2. 死锁 代码

   1. ```
      #coding=utf-8
      import threading
      import time
      
      class MyThread1(threading.Thread):
          def run(self):
              # 对mutexA上锁
              mutexA.acquire()
      
              # mutexA上锁后，延时1秒， 另外那个线程 把mutexB上锁
              print(self.name+'----do1---up----')
              time.sleep(1)
      
              # 此时会堵塞，因为这个mutexB已经被另外的线程抢先上锁了
              mutexB.acquire()
              print(self.name+'----do1---down----')
              mutexB.release()
      
              # 对mutexA解锁
              mutexA.release()
      
      class MyThread2(threading.Thread):
          def run(self):
              # 对mutexB上锁
              mutexB.acquire()
      
              # mutexB上锁后，延时1秒， 另外那个线程 把mutexA上锁
              print(self.name+'----do2---up----')
              time.sleep(1)
      
              # 此时会堵塞，因为这个mutexA已经被另外的线程抢先上锁了
              mutexA.acquire()
              print(self.name+'----do2---down----')
              mutexA.release()
      
              # 对mutexB解锁
              mutexB.release()
      #定义两个锁对象mutexA, mutexB
      mutexA = threading.Lock()
      mutexB = threading.Lock()
      
      if __name__ == '__main__':
          t1 = MyThread1()
          t2 = MyThread2()
          t1.start()
          t2.start()
      ```

   2. 运行结果

      - ```
        Thread-1----do1---up----
        Thread-2----do2---up----
        ```

2. 避免死锁
   1. 程序设计时 尽量避免（银行家算法）
   2. 添加超时时间等
3. 银行家算法
   
   1. 从当前状态出发，选一个安全序列 检查客户谁能完成其工作，假定其完成工作且归还全部贷款，再检查下一个能完成工作的客户，......。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的

#### 5.10 案例：多任务版udp聊天器

1. 任务

   1. 编写一个有2个线程的程序
   2. 线程1用来接收数据然后显示
   3. 线程2用来检测键盘数据然后通过udp发送数据

2. 代码

   1. ```
      #udp通信
      
      import socket
      import threading
      
      
      def send_msg(udp_socket):
          """获取键盘数据，并将其发送给对方"""
          while True:
              # 1. 从键盘输入数据
              msg = input("\n请输入要发送的数据:")
              # 2. 输入对方的ip地址
              dest_ip = input("\n请输入对方的ip地址:")
              # 3. 输入对方的port
              dest_port = int(input("\n请输入对方的port:"))
              # 4. 发送数据
              udp_socket.sendto(msg.encode("utf-8"), (dest_ip, dest_port))
      
      
      def recv_msg(udp_socket):
          """接收数据并显示"""
          while True:
              # 1. 接收数据
              recv_msg = udp_socket.recvfrom(1024)
              # 2. 解码
              recv_ip = recv_msg[1]
              recv_msg = recv_msg[0].decode("utf-8")
              # 3. 显示接收到的数据
              print(">>>%s:%s" % (str(recv_ip), recv_msg))
      
      
      def main():
          # 1. 创建套接字
          udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
          # 2. 绑定本地信息
          udp_socket.bind(("", 7890))
      
          # 3. 创建一个子线程用来接收数据
          t = threading.Thread(target=recv_msg, args=(udp_socket,))
          t.start()
          # 4. 让主线程用来检测键盘数据并且发送
          send_msg(udp_socket)
      
      if __name__ == "__main__":
          main()
      ```

### 5章 总结

#### 01-多任务介绍、以及Thread的基本使用

1. 并行, 真的多任务
2. 并发, 假的多任务
3. 一个程序运行后,, 有一个执行代码的东西, 这个东西就是线程
4. 函数名: 
   1. 无括号时, 引用 func
   2. 有括号时, func() 调用函数

#### 02-Thread创建线程 完成多任务

1. threading.enumerate()   #线程个数

#### 03-查看正在运行的线程、主线程等待子线程先结束

1. 运行没有先后顺序的
2. time.sleep(1)
3. 主线程死了, 所有子线程也死
4. 调用Thread时, 不创建线程, `线程对象.start()` 创建线程, 并运行
5. 函数结束, 线程结束

#### 04-通过继承Thread类完成创建线程

1. 函数线程

   1. t1 =  threading.Thread(target=函数名)

      t1.start()

2. 类线程

   1. 创建类

      1. ```
   class MyThread(threading.Thread):
         	....
         ```
      
   2. 创建实例
   
      1. `t1 = MyThread()`
   
   3. 创建线程, 并启动线程
   
      1. `t1.start()`   # 自调用run() , run() 中再调用其他方法

#### 05-通过继承Thread类完成创建线程-补充

#### 06-多线程共享全局变量

1. global  
   1. 全局变量值修改, 若 箭头指向改变, 加 global  # 变量引用改变, 加global
   2. 数字, 字符串, 元组 值不可变.  变量引用改变, 要global, 
   3. 只获取, 不用加 global

#### 07-多线程共享全局变量 -- args参数

1. threading.Thread(target=test1, args=(g_nums,))   #参数是元组
2. 共享方便, 好
   1. 多任务数据多会共享

#### 08-创建线程是指定传递的参数、多线程共享全局变量的问题

1. 资源竞争, 

#### 09-同步概念、互斥锁解决资源竞争的问题

1. mutex = threading.Lock()  # c创建锁  全局锁

2. ```
mutex.acquire()   # 上锁, 子线程中用(方法中用全局锁)
   
   ```

g_num += 1  # 被锁定的语句, 放置在上锁释放锁两个语句之间

   mutex.release()  # 释放锁
   ```

#### 10-死锁、银行家算法

1. 避免方法:
   1. 添加超时时间
   2. 银行家算法: 按规定的流程进行

#### 11-案例：多线程版udp聊天器

1. socket 是多线程的, 全双工

----

----

### 6 多任务 -- 进程

#### 6.1 进程以及状态

1. 进程
   1. 程序：例如xxx.py 是程序， 静态的
   2. 进程：一个运行的程序 ，`代码+资源` 称之 进程， 操作系统分配资源的`基本单元`。
   3. 完成多任务方法: 进程,  线程 
2. 进程的状态
   1. 就绪 态：运行的条件已经 满足，正等 cpu执行
   2. 执行 态：cpu正在执行 
   3. 等待 态：等待某些条件 ， 如一个程序sleep了， 等待态

#### 6.2 进程的创建-multiprocessing

* multiprocessing模块
  * 跨平台 的多进程模块
  * 提供  Process类, 代表一个进程对象
  * 进程对象: 一个独立的进程，可 执行另外的事情

1. 2个while循环一起执行

   1. ```
      # -*- coding:utf-8 -*-
      from multiprocessing import Process
      import time
      
      
      def run_proc():
          """子进程要执行的代码"""
          while True:
              print("----2----")
              time.sleep(1)
      
      
      if __name__=='__main__':
          p = Process(target=run_proc)   #创建进程对象p
          p.start()
          while True:
              print("----1----")
              time.sleep(1)
   ```

   2. 创建子进程

      1. 传入一个执行函数, 函数的参数，创建一个Process实例p
      2. `p.start()` 启动

2. 进程pid,  getpid()

   1. ```
      # -*- coding:utf-8 -*-
      from multiprocessing import Process
      import os   //os.getpid()
      import time
      
      def run_proc():
          """子进程要执行的代码"""
          print('子进程运行中，pid=%d...' % os.getpid())  # os.getpid获取当前进程的进程号
          print('子进程将要结束...')
      
      if __name__ == '__main__':
          print('父进程pid: %d' % os.getpid())  # os.getpid获取当前进程的进程号
          p = Process(target=run_proc)
          p.start()
      ```

   2. os, python环境下对文件，文件夹执行操作的一个模块

3. Process语法
   1. Process([group [, target [, name [, args [, kwargs]]]]])
      1. target：进程函数引用， 任务进入这个子进程 执行代码
      2. args： target函数 的参数， 元组的方式
      3. kwargs： target函数 命名参数
      4. name： 设定 进程名字，可以不设定
      5. group：指定进程组， 多数 下用不到
   2. Process 实例对象的 方法：
      1. start()：启动 子进程实例（创建子进程）
      2. is_alive()：判断 进程子进程 是否 `活着`
      3. join([timeout])：是否 `等待` 子进程 结束，或等待多少秒
      4. terminate()：立即终止子进程, 不管任务是否完成
   3. Process 实例对象的 属性：
      1. name： 进程的别名，默认为Process-N，N为从1开始递增的整数
      2. pid： 进程的pid（进程号）
   
4.  给子进程指定的函数 传递参数

   1. ```
      # -*- coding:utf-8 -*-
      from multiprocessing import Process
      import os
      from time import sleep
      
      
      def run_proc(name, age, **kwargs):
          for i in range(10):
              print('子进程运行中，name= %s,age=%d ,pid=%d...' % (name, age, os.getpid()))
              print(kwargs)
              sleep(0.2)
      
      if __name__=='__main__':
          p = Process(target=run_proc, args=('test',18), kwargs={"m":20})
          p.start()
          sleep(1)  # 1秒 后，立即结束子进程
          p.terminate()
          p.join()
      ```

   2. 运行结果

      ```
      子进程运行中，name= test,age=18 ,pid=10916...
      {'m': 20}
      子进程运行中，name= test,age=18 ,pid=10916...
      {'m': 20}
      子进程运行中，name= test,age=18 ,pid=10916...
      {'m': 20}
      子进程运行中，name= test,age=18 ,pid=10916...
      {'m': 20}
      子进程运行中，name= test,age=18 ,pid=10916...
      {'m': 20}
      ```

5. 进程间不同享 `全局变量`

   1. ```
      # -*- coding:utf-8 -*-
      from multiprocessing import Process
      import os
      import time
      
      nums = [11, 22]
      
      def work1():
          """子进程要执行的代码"""
          print("in process1 pid=%d ,nums=%s" % (os.getpid(), nums))
          for i in range(3):
              nums.append(i)
              time.sleep(1)
              print("in process1 pid=%d ,nums=%s" % (os.getpid(), nums))
      
      def work2():
          """子进程要执行的代码"""
          print("in process2 pid=%d ,nums=%s" % (os.getpid(), nums))
      
      if __name__ == '__main__':
          p1 = Process(target=work1)
          p1.start()
          p1.join()  # p1进程结束 后 再执行p2进程
      
          p2 = Process(target=work2)
          p2.start()
          p2.join()
      ```

   2. ```
      # 注意 两个 join 区别
      if __name__ == '__main__':
          p1 = Process(target=work1)
          p1.start()    
      
          p2 = Process(target=work2)
          p2.start()
          p1.join()  # p1进程结束
          p2.join()  # p2进程结束
      ```

#### 6.3 进程、线程对比

1. 功能
   1. 处理多任务
   2. 进程,  如 一台电脑上 同时运行多个QQ
   3. 线程,  如 一个QQ中 多个聊天窗口
2. 定义的不同
   1. 进程 :  资源分配和调度的一个最小`单位`
   2. 线程 : 
      1. 进程的一个实体. 线程 是 `CPU` 调度和分派的 基本单位
      2. 比进程更小, 能独立运行的基本单位
      3. 线程: 不拥有系统资源, 有一点运行 必不可少的资源
      4. 它 与同一个进程的其他的线程 共享 进程的全部资源.
3. 区别
   1. 程序至少有一个进程,  进程至少有一个线程.
   2. 线程尺度小于进程(资源比进程少)， 多线程程序 高并发性。
   3. 进程 有 独立 的内存单元.  多个线程共享内存， 提高 程序 运行效率
   4. 线程不能独立执行， 依存在进程中
   5.  进程 类似 一条流水线， 线程 类似流水线上的工人
   6. 线程 开销小，但不利于资源的管理和保护； 进程 相反。

#### 6.4 进程间通信  Queue

1. Queue 使用

   1. multiprocessing模块的Queue 实现多进程间 数据传递，Queue :  消息列队 

   2. Queue的工作原理

      ```
      #coding=utf-8
      from multiprocessing import Queue
      q=Queue(3) #初始化一个Queue对象，最多可接收三条put消息
      q.put("消息1")  #放入数据
      q.put("消息2")
      print(q.full())  #False
      q.put("消息3")
      print(q.full()) #True
      
      #消息列队已满,try会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常
      try:
          q.put("消息4",True,2)
      except:
          print("消息列队已满，现有消息数量:%s"%q.qsize())
      
      try:
          q.put_nowait("消息4")
      except:
          print("消息列队已满，现有消息数量:%s"%q.qsize())
      
      #推荐的方式，先判断消息列队是否已满，再写入
      if not q.full():
          q.put_nowait("消息4")
      
      #读取消息时，先判断消息列队是否为空，再读取
      if not q.empty():
          for i in range(q.qsize()):
              print(q.get_nowait())
      ```

      执行结果:

      ```
      False
      True
      消息列队已满，现有消息数量:3
      消息列队已满，现有消息数量:3
      消息1
      消息2
      消息3
      ```

      Queue() 是队列, 先进先出

   3. Queue()类 总结:

      1. 初始化Queue()对象 （例如：q=Queue()）

         1.  没 指定 数量，或 负值， 可接受的消息数量没 上限（直到内存的尽头）；

      2. Queue.qsize()：返回: 队列 消息数量；

      3. Queue.empty()： 队列 空，返回True，反之False ；

      4. Queue.full()： 判断队列满了，返回True,反之False；

      5. Queue.get([block[, timeout]])：获取 一条消息， 并从列队中 移除.

         1. 参数:
            1. block:  可选
               1. 默认值 True，且没有设 timeout（单位秒）
                  1. 若列队 空，此时程序 被阻塞（停在读取状态），直到从消息列队读到消息为止
                  2. 若 设置`timeout`，则 等待timeout秒，若还没取到 消息，则抛出"Queue.Empty"异常；
               2.  False
                  1. 若 消息列队 空，则 立刻抛出"Queue.Empty"异常；
         2. timeout: 可选, 等待时间, 单位 秒

      6. Queue.get_nowait() # 相当Queue.get(False)

      7. Queue.put(item,[block[, timeout]])  # 

         1. 参数:
            1.  item消息写入队列
            2. block: 可选
               1. 默认值 True, 
                  1. 没设置timeout（单位秒）若 消息列队 满，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止
                  2. 设置了timeout，则 等待timeout秒，若还没空间，则抛出"Queue.Full"异常；
               2. 值 False，消息列队 满，则 立刻抛出"Queue.Full"异常；

      8. Queue.put_nowait(item) # 相当Queue.put(item, False)

         

2. Queue 例

   1.  父进程中创建两个子进程，一个进程往Queue 写数据，一个进程从Queue 读数据

   2. ```
      from multiprocessing import Process, Queue
      import os, time, random
      
      # 写数据进程执行的代码:
      def write(q):
          for value in ['A', 'B', 'C']:
              print('Put %s to queue...' % value)
              q.put(value)
              time.sleep(random.random())
      
      # 读数据进程执行的代码:
      def read(q):
          while True:
              if not q.empty():
                  value = q.get(True)
                  print('Get %s from queue.' % value)
                  time.sleep(random.random())
              else:
                  break
      
      if __name__=='__main__':
          # 父进程创建Queue，并传给各个子进程：
          q = Queue()
          #创建两个子进程 pw, pr. q做参数
          pw = Process(target=write, args=(q,)) 
          pr = Process(target=read, args=(q,))
          # 启动子进程pw，写入:
          pw.start()
          # 等待pw结束:
          pw.join()
      
          # 启动子进程pr，读取:
          pr.start()
          # 等待pr结束:
          pr.join()
      
          # pr进程里是死循环，无法等待其结束，只能强行终止:
          print('')
          print('所有数据都写入并且读完')
      ```
```
      
3. 运行结果
   
```
      Put A to queue...
      Put B to queue...
      Put C to queue...
      Get A from queue.
      Get B from queue.
      Get C from queue.
      
      所有数据都写入并且读完
      ```

6.5 进程池Pool

1. 进程池Pool

   1. 使用情景

      1. 进程数不多,  用 multiprocessing 的 Process  动态成生多个 进程
      2. 进程数很多,  用 multiprocessing 的 Pool方法

   2. Pool 示例

      1. ```
         # -*- coding:utf-8 -*-
         from multiprocessing import Pool
         import os, time, random
         
         def worker(msg):
             t_start = time.time()
             print("%s开始执行,进程号为%d" % (msg,os.getpid()))
             # random.random()随机生成0~1之间的浮点数
             time.sleep(random.random()*2)
             t_stop = time.time()
             print(msg,"执行完毕，耗时%0.2f" % (t_stop-t_start))
         
         
         
         if __name__ =="__main__":
             
             po = Pool(3)  # 定义一个进程池，最大进程数3
             for i in range(0, 10):
                 # Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))
                 # 每次循环将会用空闲出来的子进程去调用目标
                 po.apply_async(worker, (i,))  #添加子进程
             print("----start----")
             po.close()  # 关闭进程池，关闭后po不再接收新的请求
             po.join()  # 等待po中所有子进程执行完成，必须 在close语句之后
             print("-----end-----")
         ```

      2. 运行结果

         ```
         ----start----
         0开始执行,进程号为5004
         1开始执行,进程号为6468
         2开始执行,进程号为4372
         2 执行完毕，耗时0.89
         3开始执行,进程号为4372
         1 执行完毕，耗时1.16
         4开始执行,进程号为6468
         3 执行完毕，耗时0.37
         5开始执行,进程号为4372
         5 执行完毕，耗时0.43
         6开始执行,进程号为4372
         0 执行完毕，耗时1.93
         7开始执行,进程号为5004
         4 执行完毕，耗时1.20
         8开始执行,进程号为6468
         8 执行完毕，耗时0.57
         9开始执行,进程号为6468
         9 执行完毕，耗时0.17
         6 执行完毕，耗时1.78
         7 执行完毕，耗时1.78
         -----end-----
         ```

   3. multiprocessing.Pool 的方法

      1. apply_async(func[, args[, kwds]]) 
         1. 作用: 非阻塞方式调用 func,  并行执行.  (堵塞方式必须等待上一个进程退出才能执行下一个进程），
         2. 参数:
            1. func, 调用的函数名func
            2. args  :  func 参数列表
            3. kwds : func 关键字参数列表
         3. 区别: apply()(func[, args[, kwds]]) , 阻塞方式调用 func,  并行执行
      2. close()：关闭Pool，使其不再接受新的任务
      3. terminate()：立即终止, 不管任务是否完成
      4. join()：主进程阻塞，等待子进程结束， 必须在close,terminate方法 后 

2. 进程池的Queue

   1. 理论:

      1. Pool 进程池，要用 multiprocessing.Manager().Queue()
      2. 不要用 multiprocessing.Queue()，否则报错：
         1. RuntimeError: Queue objects should only be shared between processes through inheritance

   2. 示例

      1. ```
         # -*- coding:utf-8 -*-
         
         # 修改import中的Queue为Manager
         from multiprocessing import Manager,Pool
         import os,time,random
         
         def reader(q):
             print("reader启动(%s),父进程为(%s)" % (os.getpid(), os.getppid()))
             for i in range(q.qsize()):
                 print("reader从Queue获取到消息：%s" % q.get(True))
         
         def writer(q):
             print("writer启动(%s),父进程为(%s)" % (os.getpid(), os.getppid()))
             for i in "itcast":
                 q.put(i)
         
         if __name__=="__main__":
             print("(%s) start" % os.getpid())
             q = Manager().Queue()  # 使用Manager().Queue()
             #创建进程池
             po = Pool()
             #进程池调用函数创建子进程, q做参数
             po.apply_async(writer, (q,))
         
             time.sleep(1)  # 先让上面的任务向Queue存入数据，然后再让下面的任务开始从中取数据
         	#进程池调用函数创建子进程, q做参数
             po.apply_async(reader, (q,))
             po.close()
             po.join()
    print("(%s) End" % os.getpid())
         ```
   
      2. 结果
      
         ```
         (10752) start
         writer启动(10368),父进程为(10752)
         reader启动(10368),父进程为(10752)
         reader从Queue获取到消息：i
         reader从Queue获取到消息：t
         reader从Queue获取到消息：c
         reader从Queue获取到消息：a
         reader从Queue获取到消息：s
         reader从Queue获取到消息：t
   (10752) End
         ```
      
         

#### 6.6  案例:  文件夹copy器（多进程版）

1. ```
   import multiprocessing
   import os
   import time
   import random
   
   
   def copy_file(queue, file_name,source_folder_name,  dest_folder_name):
       """copy文件到指定的路径"""
       f_read = open(source_folder_name + "/" + file_name, "rb")
       f_write = open(dest_folder_name + "/" + file_name, "wb")
       while True:
           time.sleep(random.random())
           content = f_read.read(1024)
           if content:  #非空
               f_write.write(content)
           else:
               break
       f_read.close()
       f_write.close()
   
       #文件名放入消息队列中(发送已经拷贝完毕的文件名字)
       queue.put(file_name)
   
   
   def main():
       # 获取源文件夹
       source_folder_name = input("请输入要复制文件夹名字:")
   
       # 创建目标文件夹
       dest_folder_name = source_folder_name + "[副本]"
   
       # 创建目标文件夹
       try:
           os.mkdir(dest_folder_name)
       except:
           pass  # 如果文件夹已经存在，那么创建会失败
   
       # 获取这个文件夹中所有的普通文件名
       file_names = os.listdir(source_folder_name)
   
       # 创建进程池的Queue对象
       queue = multiprocessing.Manager().Queue()
   
       # 创建进程池
       pool = multiprocessing.Pool(3)
   
       for file_name in file_names:
           # 向进程池中添加任务:copy_file函数名
           pool.apply_async(copy_file, args=(queue, file_name, source_folder_name, dest_folder_name))
   
       #关闭进程池. 
       pool.close()
   	
   	#显示进程进度
       all_file_num = len(file_names)
       while True:
           file_name = queue.get()
           if file_name in file_names:
               file_names.remove(file_name)
   
           copy_rate = (all_file_num-len(file_names))*100/all_file_num
           print("\r%.2f...(%s)" % (copy_rate, file_name) + " "*50, end="")
           if copy_rate >= 100:
               break
       print()
   
   
   if __name__ == "__main__":
       main()
   ```
```
   
2. 总结:

   1. 文件 操作函数:
      1. open()
      2. f_read.read()
      3. f_write.write(content)
      
   2. os 操作
      1. os.mkdir
      2. os.listdir
      
   3. Queue()
      1. 不同进程间 数据  都放入Queue
      2. 相当于一个容器
      
   4. Pool
      1. pool = multiprocessing.Pool(3)
      2. pool.apply_async(copy_file, args=(queue, file_name, source_folder_name, dest_folder_name))
      3. pool.close()
      
   5. list类型的 remove()方法
   
      1. ```
         l1 = [1, 2, 3, 4]
         l1.remove(1)
         l1  #输出[2, 3, 4]
```

----

### 6 多任务-进程- 总结

##### 01-线程知识点复习

1. 

##### 02-进程、程序的概念

1. 程序, 硬盘上的代码,  菜谱. 一个
2. 进程: 内存中运行的程序,  可以多个, 类似一个菜谱做多个菜. 
   1. 资源分配的单位.
   2. 代码+ 资源 = 进程
   3. 资源: 内存, 网卡, CPU 等

##### 03-使用Process完成多进程

1. 状态: 就绪, 运行, 等待, 新建,死亡

2. ```
import multiprocessing
   Process
p1 = multiprocessing.Process(target=test1, args=())
   p1.start()  # 创建, 并开启子进程1
   ```
   
3. linu命令
      1. 多行注释:   V,选中, :  normal i #     
      2. ps -aux  # 进程
      3. kill  34  # 杀死进程号
##### 04-使用Process完成多进程-补充

1. 主进程-->子进程,  进程号不同
2. 进程 浪费资源
3. 进程代码 一样,  数据不一样. 
   1. 编写时拷贝

##### 05-进程、线程的区别

1. 进程: 浪费资源.  QQ多个开启.  多份资源, 一个资源一个箭头
   1. 进程 **资源分配单位**, 
2. 线程: 资源少,  一个QQ开启多个窗口,  一个资源多个箭头
   1. 线程: **任务调度单位**
   2.  线程做工作

##### 06-通过队列完成进程间通信

1. socket: 进程间 通信

   1. 文件: 通过磁盘

2. Queue, 内存中一块区域

   1. ```
      from multiprocessing import Queue
      q.put()
      q.get()  # q.get_nowait()
      q.full()
      q.qsize()
      q.empty() 
      ```

3. 多进程通过Queue实现数据共享

   1. 只能同一个电脑,

   2. 完成进程间数据共享

   3. 示例

      1. ```
         q = multiprocessing.Queue()   # main()中变量
         p1 = multiprocessing.Process(target=test1, args=(q,))
         p2 = multiprocessing.Process(target=test2, args=(q,))
         ```


   4. 此处, 主进程等待子进程执行

##### 07-进程池概述

1. 重复利用
2. 进程池Pool中是资源

##### 08-进程池的创建

1. 任务数确定 用进程,  任务数不确定用Pool()

2. ```
   from multiprocessing import Pool
   po = Pool(3)  #最大进程数
   po.apply_async(work, (i))   # 参数: 任务, (数组参数)
   po.close()  # 关闭进程池, 必须放join() 前
   po.join()  # 等待子进程执行完后, 主进程再向下
   ```

3. Pool中 主进程 不 等待 子进程

4. linux命令

   1. ` .`  重复上一个命令

##### 09-案例：多任务文件夹copy

1. linux命令:

   1. `os.__file__`  # 查看路径
   2. `cp a/*.py  ./ `
   3. `tree`
   
2. ```
   # 先写框架
   # 框架
   ```

   1. 先if
   2. 在main
      1. main() 中框架
      2. 调用的函数

3. 进程池中异常不输出

4. Queue()两种方式: 
   1. multiprocessing.Queue()   # 进程间传递数据
   2. multiprocessing.Manager.Queue()   # 进程池传递数据

---

### 7 多任务 - 协程

#### 7.0 迭代器

* 可迭代对象 Iterable,  迭代器 Iterator.  是不同的两种对象类型

* ~~迭代器 iterator~~

  * ~~迭代 : 从集合中按 条 获取元素的一种访问方式~~

  * ~~迭代器 :  记住遍历的位置的对象 ~~

  * ~~迭代器对象 : 从集合的第一个元素开始, 直到所有元素被访问完~~

  * ~~迭代器只能往前不会后退。~~

  * ~~这是删除线~~

    

1. 可迭代对象/  Iterable 对象,  (I 是 大写的 i)

   1. 可迭代对象/ Iterable对象 : 能用 for...in...遍历,按条获取数据 的对象
   2. 遍历/ 迭代: 用 for...in... 从 list、tuple、str等类型的数据中 一条一条 获取数据的 方法叫 **遍历**，也叫**迭代**
   3. 可迭代 是 形容词, 可迭代的对象 叫 可迭代对象, Iterable 对象

2.  判断对象是否 可迭代

   1.  isinstance() 判断  Iterable

      1. ```
         In [51]: isinstance([], Iterable)
         Out[51]: True
         ```

3. 可迭代对象 的本质

   1. **可迭代对象 的本质: 提供 迭代器 实现 可迭代对象 的遍历**

       1. 可迭代对象: 是有`__iter__()`方法的对象
       
   2. ```
      class MyList(object):
          def __init__(self):
                  self.container = []
          def add(self, item):
                  self.container.append(item)
          def __iter__(self):
               # 我们暂时忽略如何构造一个迭代器对象
                  pass
                  
      #测试:
      mylist = MyList()
      
      from collections import Iterable  # 导入Iterable类
      isinstance(mylist, Iterable) # 输出 True
      ```
      
      1. 有`__iter__`方法的mylist对象 是一个可迭代对象	
      
   3. 总结: 
          1. 类中 有 `__iter__(self)`方法
       2. 该类生成的对象 是 可迭代对象

          3. 访问 **可迭代对象** 的过程:
                1. 先 获 可迭代对象 提供的 **迭代器**
                   1. 可迭代对象用 `__iter__()`方法提供迭代器
                2. 然后用迭代器 **依次** 获取可迭代对象 的每一个数据.

4. **iter()    next()** 

   1. 区别:  参数不同, 返回值不同

      1.  `iter()` , #生成迭代器
         1.   参数: 可迭代对象
         2.  返回值: 迭代器 Iterator
         3.  `iter(a)` 实际上 调用了可迭代对象`__iter__`方法, a是可迭代对象
      2.  `next()`,  #取值
          1.  参数: 迭代器
          2.  返回值: 迭代器的下一数据.
          3.  `next(b)` 实际上 调用了迭代器(对象)`__next__`方法,  b 迭代器(对象)

   2. list、tuple 可迭代对象 的操作

      1. 原文: 
         1. list、tuple等都是可迭代对象, 通过iter()函数获取这些可迭代对象的迭代器
         2. next(迭代器), 获取下一条数据
         3. iter()函数实际上是调用了可迭代对象的`__iter__`方法。
      
   3. ```
      li = [11, 22, 33, 44, 55]
      li_iter = iter(li)  // 返回值 迭代器
      next(li_iter)  // 返回值 当前位置的下一个位置对应的数据
      ```

   4. 迭代完 数据 后, 继续 调用next() 会抛出 StopIteration 异常

5. 判断一个对象是否是 迭代器

   1. ```
      from collections import Iterator  #Iterator 迭代器
      isinstance([], Iterator)  #输出 False
      
      isinstance(iter([]), Iterator) #输出True
      ```

6. 迭代器 Iterator

   1. next()函数 调用的 是迭代器对象的`__next__`方法

      1. Python3 中 是对象的`__next__`方法，Python2中 是对象的next()方法
      2. 迭代器 的next() 机制: 
         1. 迭代器 返回 记录的位置的下一个位置的数据
         2. 总结: 迭代器有 记录位置的功能

   2. 构造 `迭代器类`

      1. 先 实现迭代器类的 `__next__` 方法 
      2. 再 实现迭代器类的 `__iter__` 方法. 
         1. iter()方法 返回值是 迭代器Iterator(对象)
         2. 迭代器类是 类,
         3. 迭代器 是 实例
      3. 总结:   实现了`__iter__`和`__next__`方法的类 是迭代器类

   3. 可迭代类 构成

      1.  list 作 数据结构,  存储数据
      2. add 方法, 用 append() 实现
      3. `__iter__()` 魔法方法

   4. 定义 可迭代对象类, 迭代器类

      1. ```
         #定义可迭代对象类
         class MyList(object):
             """自定义的一个可迭代对象类"""
             def __init__(self):
             	#items列表存储数据(数据结构)
                 self.items = []
         
             def add(self, val):
                 self.items.append(val)
         
             def __iter__(self):
                 myiterator = MyIterator(self)  #生成一个迭代器类的实例
                 return myiterator ## 返回该可迭代对象的迭代器类的实例  
         
         #定义迭代器类,其是MyList类的可迭代对象的迭代器类  
         class MyIterator(object):
             """自定义的供上面可迭代对象使用的一个迭代器"""
             def __init__(self, mylist):
                 self.mylist = mylist   #用可迭代对象初始化
                 # current用来记录当前访问到的位置
                 self.current = 0
         	
         	#用位置标记元素, 取下一个元素值
             def __next__(self):  # 迭代器类必须实现的方法
                 if self.current < len(self.mylist.items):
                     item = self.mylist.items[self.current]
                     self.current += 1
                     return item
                 else:
                     raise StopIteration
         
             def __iter__(self):
                 return self  ## 返回迭代器类的实例；自己是迭代器，所以返回self  
         
         
         if __name__ == '__main__':
             mylist = MyList()
             mylist.add(1)
             mylist.add(2)
             mylist.add(3)
             mylist.add(4)
             mylist.add(5)
       for num in mylist:
                 print(num)
         ```
         
         1. 小结
         
            1. 可迭代类 用 list列表  数据结构, 存储数据,  list用 append() 添加元素
            2. 迭代器作可迭代对象类 的内部对象
            3. 可迭代对象 经 迭代器类的`__init__`初始化,  由 迭代器的魔法方法`__iter__` 返回 一个迭代器(对象)
         
         2. 可迭代类 和 迭代器类的关系
            1. 两个没有继承关系的类
            2.  迭代器(对象) 是 可迭代对象类 的内部对象. 
               1. 迭代器类 转换数据对象, 返回 迭代器(对象)
               2. 可迭代类的 数据结构是 lis列表
            3. 可迭代对象类, 实现了`__iter__`方法
            4. 迭代器类, 实现了`__iter__, __next__`方法,  是`__next__`不是next
         
         3. 可迭代对象，迭代器，生成器关系
         
            1. 可迭代对象 包括 迭代器, 序列(字符串, 列表, 元组), 字段
         
            2. 迭代器 包括 生成器. 即 可迭代对象包括生成器
         
            3. ```mermaid
               flowchart LR
               A[可迭代对象]
               B[迭代器]
               C[生成器]
               D["序列(字符串, 列表, 元组)"]
               F[字典]
               A --> B --> C
               A --> D
               A --> F
               ```
         
               https://blog.csdn.net/liangjisheng/article/details/79776008

      

7. for...in...循环的本质

   1. for **item** in **Iterable** 循环
   2. 本质 :  iter()函数获取 可迭代对象Iterable 的迭代器, 迭代器 调用next()方法 获取下一个值并将其赋值给item，当遇到StopIteration异常后循环结束

8. 迭代器的应用场景

   1. 迭代器 核心功能: 通过next(迭代器)函数 返回下一个数据值

   2. 不用 将要迭代的数据 一次性缓存, 可节省 存储（内存）空间

   3. 用 迭代器 实现Fibonacci数列

      1. ```
         class FibIterator(object):
             """斐波那契数列迭代器类"""
             def __init__(self, n):
                 """
                 :param n: int, 指明数列的前n个数
                 """
                 self.n = n
                 # current用来保存当前生成到数列中的第几个数了
                 self.current = 0
                 # num1 保存前前一个数，初始值为数列中的第一个数0
                 self.num1 = 0
                 # num2 保存前一个数，初始值为数列中的第二个数1
                 self.num2 = 1
         	
         	#取下个位置的值
             def __next__(self):
                 """ next()函数 获取下一个数"""
                 if self.current < self.n:
                     num = self.num1
                     self.num1, self.num2 = self.num2, self.num1+self.num2
                     self.current += 1
                     return num
                 else:
                     raise StopIteration
         	
         	#返回迭代器(迭代器类对象)
             def __iter__(self):
                 """迭代器的__iter__返回自身即可"""
                 return self
         
         
         if __name__ == '__main__':
             fib = FibIterator(10)
             for num in fib:
                 print(num, end=" ")
         ```

9.  接收 可迭代对象 的结构

   1. for循环, list、tuple 接收 可迭代对象

   2. ```
      li = list(FibIterator(15))
      print(li)
      tp = tuple(FibIterator(6))
      print(tp)
      ```

#### 7.1 生成器  generator

1. 生成器

   1. 有 yield 的函数 是生成器

      1. yield 理解为return，返回值给调用者
      2. 不同的是return返回后，函数会释放，生成器则不会
      3. 调用next 或for语句下一次迭代时，生成器从yield下一句开始执行，直至遇到下一个yield

   2. 特殊的迭代器，自动实现了“迭代器协议”（即`__iter__`和`__next__`），不需要再手动实现

   3. 生成器 功能:

      1. 记录当前状态(位置), 
      2. 配合next() 函数 迭代

   4. 生成器与迭代器区别:

      1. 生成器在迭代中可改变当前迭代值
      2. 普通迭代器的改变当前迭代值会发生异常

      

2. 创建生成器方法1 : ` [ ] 改成 ( )`

   1. 列表生成式的 [ ] 改成 ( ) ,  变成`生成器`

   2. 示例

      1. ```
         # list 列表
         In [15]: L = [ x*2 for x in range(5)]
         
         In [16]: L
         Out[16]: [0, 2, 4, 6, 8]
         
         # 生成器
         In [17]: G = ( x*2 for x in range(5))
         
         In [18]: G
         Out[18]: <generator object <genexpr> at 0x7f626c132db0>
         ```

      2. 总结

         1. 创建 L 和 G 的区别仅在于最外层的 [ ] 和 ( ) 

         2. L 是 列表， 直接打印 L的每一个元素

         3. G 是 生成器, 按 迭代器 使用,用 next(),for循环,list()操作

            1. ```
               next(G)
               ```

            2. ```
               for x in G:
                  print(x)
               ```

            3. ```
               list(G)
               ```

         4. 元素 从 G 中取出后, G对应元素 删除

            1. 取一个 ,少一个

3. 创建生成器方法2: 含`yield`函数

   1. 在def中有yield关键字的 就称为 生成器.

      1.  含 yield 的函数, 不再是函数, 是生成器.

   2. 示例1: 生成器 解决 Fibonacci

      1. ```
         def fib(n):
            current = 0
            num1, num2 = 0, 1
            while current < n:
                num = num1
                num1, num2 = num2, num1+num2
                current += 1
                yield num
            return 'done'
            
         F = fib(5)
         next(F)
         ```

   3. 示例2

      1. ```
         #!/usr/bin/env python  
         # coding=utf-8  
           
         #定义生成器类
         def myList(num):        
             now = 0           #当前迭代值，初始为0  
             while now < num:  
                 val = (yield now)  #返回当前迭代值，并接受可能的send发送值
                 now = now + 1 if val is None else val  # val为None，迭代值自增1，否则重新设定当前迭代值为val  
         
         #得到一个生成器对象
         my_list = myList(5)     
           
         print(my_list.next())  #返回当前迭代值  
         print(my_list.next())
           
         my_list.send(3)       #重新设定当前的迭代值  
         print(my_list.next())
           
         print(dir(my_list))  #返回该对象所拥有的方法名，可以看到__iter__与__next__在其中 
         ```

   4. for 循环 无法拿到 生成器 的返回值

      1.  for循环调用generator, 拿不到generator的`return`语句的返回值。
      2.  想要拿到返回值，必须捕获StopIteration错误，返回值在StopIteration的value中

   5. 总结: 

      1.  含yield的函数是生成器。（使用了yield的函数就是生成器）
      2.  yield关键字有两点作用：
          1.  保存当前运行状态（断点）, 暂停执行，即将生成器（函数）挂起
          2.  yield 后 表达式的值作为返回值 ， 可 理解为 return 作用
      3.  next()函数 让生成器从断点处 执行，即唤醒生成器（函数）
      4.  区别:
          1.  Python3中 生成器可用`return`返回最终值
          2.  Python2中 生成器不允许使用`return`返回 值（即可以使用return从生成器中退出，但return后不能有任何表达式）。

4. send()唤醒生成器

   1. 唤醒生成器继续执行方法:  next(),  send()

      1.  `send(生成器)`
      2.  `生成器.send(参数值)`

   2. send() 好处 : 唤醒的同时 向断点传 附加数据

      1.  示例

      2.  ```
          def gen():
              i = 0
          
              while i < 5:
                  temp = yield i
                  print(temp)
                  i += 1
          

          if __name__=='__main__':
          	f = gen()
              c = next(f)
              print(c)
              f.send('python')
          ```
      3. 执行到yield时，gen函数 暂时保存，返回i的值; temp接收下次f.send("python") 发送 的值
      4. c.next()等价c.send(None)

      


-------

廖雪峰- 关于迭代, 可迭代对象, 迭代器

1. 迭代 :  `for`循环 遍历 list或tuple，称为迭代（Iteration）

   1. Python中，迭代 通过`for ... in` 完成

2. 可迭代对象 Iterable

   1. 可用`for`循环遍历的对象 称为  可迭代对象`Iterable`

3. 生成器generator

   1. 在Python中，一边循环一边计算的`机制`，称为生成器：

   2. 特点: 循环中计算得出元素, 元素事先不存在

   3. 通过`next()`函数获得generator的下一个返回值

   4. 使用`for`循环获取元素， generator也是 可迭代对象 Iterable

   5. 函数定义中含有`yield`，函数 不是 普通函数，而是 generator

      1. ```
         def fib(max):
             n, a, b = 0, 0, 1
             while n < max:
                 yield b
                 a, b = b, a + b
                 n = n + 1
             return 'done'
         f = fib(6)
         f  # <generator object fib at 0x104feaaa0>
         ```

   6. generator的函数， 每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从`yield`语句后继续执行

4. 迭代器

   1. 被`next(迭代器)`函数调用并不断返回下一个值的对象称为迭代器`Iterator`

   2. `isinstance()`判断一个对象是否是`Iterator`对象

   3. 生成器都是`Iterator`对象，

   4. `list`、`dict`、`str`是`Iterable`， 不是`Iterator`。

      用`iter()`函数把`list`、`dict`、`str`等`Iterable`变成`Iterator`可以使

     5. 为什么`list`、`dict`、`str`等数据类型不是`Iterator`？

          1. python的`Iterator`对象 是一个 `数据流`，Iterator对象被`next()`函数调用并不断返回下一个数据，直到没有数据时抛出`StopIteration`错误
          2. 把这个数据流看做是一个有序序列，但不能提前知道序列的长度，只能 通过`next()`函数 计算下一个数据
          3. `Iterator`的计算是惰性的，只有需要返回下一个数据时 它才计算。

----



#### 7.2 协程 

1. 协程  

   1.  特点
       1.  python 中 多任务的 另一种方式
       2.  比线程更小, 占用更小执行单元（资源）
   2.  协程  定义: 
       1.  线程 中, 在任何地方保存 当前函数 的一些`临时变量`信息，然后`切换`到另外一个函数中执行
       2.  不是通过 `调用函数` 的方式做到的
       3.  切换的次数和 什么时候再切换到原来的函数 由 `开发者` 确定

2. 协程和线程对比: 

   1.  线程的切换: `耗性能`,  线程都有 `Cache`(缓存) 数据
   2.  协程的切换: 单纯的操作 CPU的`上下文`， 一秒钟切换 百万次系统都可以


#### 7.3 yield 实现协程

1. yield 

   1.  yield功能:  保存当前状态, 并返回当前结果, 还能继续执行

2. ```
   import time
   
   def work1():
       while True:
           print("----work1---")
           yield
           time.sleep(0.5)
   
   def work2():
       while True:
           print("----work2---")
           yield
           time.sleep(0.5)
   
   def main():
       w1 = work1()
       w2 = work2()
       while True:
           next(w1)
           next(w2)
   
   if __name__ == "__main__":
       main()
   ```

   1.  yield  保存当前状态,  再次触发时 接着执行

#### 7.4 greenlet 实现协程

1. greenlet模块

   1. 封装 yield ,更好的使用协程 完成多任务
   2. 人工切换, (比较麻烦)
   3. 安装方式  `sudo pip3 install greenlet`

2. greenlet 示例:

   1. ```
      #coding=utf-8
      
      from greenlet import greenlet
      import time
      
      def test1():
          while True:
              print( "---A--")
              gr2.switch()
              time.sleep(0.5)
      
      def test2():
          while True:
              print ("---B--")
              gr1.switch()
              time.sleep(0.5)
      
      #创建greenlet对象
      gr1 = greenlet(test1)
      gr2 = greenlet(test2)
      
      #切换到gr1中运行
      gr1.switch()
      ```
```
      
1.  两个函数 轮回 切换
      
         1. 生成 gr1 = greenlet(函数名)  # 函数引用, 没有括号
   2. 切换  gr1.switch()  # 从当期程序 切换到 gr1
      
2. 运行效果
      
         1. ```
            ---A--
            ---B--
            ---A--
            ....
```

         2. 依次运行的, 不是交替运行的

#### 7.5 协程 - gevent

1. greenlet, gevent 比较

   1.  greenlet  人工切换, 麻烦
   2. gevent  自动切换任务(函数), 功能强大, 
   3.  pip3 install  gevent

2. 原理

   1. gevent 基于greenlet 实现的
   2. greenlet遇到IO( input output 输入输出， 如网络、文件操作 )操作时， 自动切换到其他的greenlet，等 IO操作完成，适当 时候切换回来继续执行

3.  gevent 使用

   1. ```
      import gevent
      
      def f(n):
          for i in range(n):
              print(gevent.getcurrent(), i)
      
      g1 = gevent.spawn(f, 5)
      g2 = gevent.spawn(f, 5)
      g3 = gevent.spawn(f, 5)
      g1.join()
      g2.join()
      g3.join()
      ```

      1. gevent.getcurrent()   # 获取当前协程
      2. g1 = gevent.spawn(f, 5)  # spawn 产卵, 大量生成
      3. g1.join()   # 实现了进程转换
      4. 没有sleep(), 即 没有时间延时 3 个 greenlet 是依次运行, 不是交替运行

4. gevent 切换执行  

   1. ```
      import gevent
      
      def f(n):
          for i in range(n):
              print(gevent.getcurrent(), i)
              #用来模拟一个耗时操作，注意不是time模块中的sleep
              gevent.sleep(1) #用gevent.sleep()实现交替转换, 不是依次转换
      
      g1 = gevent.spawn(f, 5)
      g2 = gevent.spawn(f, 5)
      g3 = gevent.spawn(f, 5)
      g1.join()
      g2.join()
      g3.join()
      ```

      1. sleep(), 时间延迟,  实现 3 个 gevent 交替运行, 不是 依次,  sleep() 与 join() 配合,交替切换
      2. gevent.getcurrent()  # 获取当前协程
      3. gevent 用 gevent.sleep(1)  不是 time.sleep(1)

5. 给程序打补丁

   1. ```
      from gevent import monkey
      import gevent
      import random
      import time
      
      def coroutine_work(coroutine_name):
          for i in range(10):
              print(coroutine_name, i)
              gevent.sleep(random.random())
      
      
      gevent.joinall([
              gevent.spawn(coroutine_work, "work1"),
              gevent.spawn(coroutine_work, "work2")
      ])
      ```

      1. 当用time.sleep()时, gevent.joinall() 不能交替切换,

   2. ```
      from gevent import monkey
      import gevent
      import random
      import time
      
      #耗时操作时需要, 只添加一句话即可
      #程序中耗时操作的代码，换为gevent中自己实现的模块
      monkey.patch_all()  
      
      def coroutine_work(coroutine_name):
          for i in range(10):
              print(coroutine_name, i)
              time.sleep(random.random())
      
      gevent.joinall([
              gevent.spawn(coroutine_work, "work1"),
              gevent.spawn(coroutine_work, "work2")
      ])
      ```
```
      
      1. 添加 monkey.patch_all()后, 遇到耗时, gevent模块自动切换
2. monkey.patch_all() 与 gevent.joinall()  配合使用
      
3. gevent 模块总结
   
      1. 与gevent.monkey模块配合, 实现gevent模块自动切换
      2. monkey.patch_all()  #耗时切换
      3. gevent.spawn()   # 创建一个协程对象
      4. gevent.joinall((gevent协程1, .., gevent协程n))  # 启动各个线程, 不自动切换. 与monkey.patch_all() 配合, 实现自动切换
      5. g1.join() 配合 `gevent.sleep()` 才能自动切换. 
         1. g1是一个协程对象
      
   4. gevent.sleep()与 time.sleep()区别
   
      1. `gevent.sleep()` will yield the current greenlet to the gevent hub, allowing other greenlets to run. 
      2. `time.sleep()` will not yield to the hub; it will simply suspend the entire current thread and  all greenlets that might like to run on it.

#### 7.6 进程、线程、协程对比

1. 通俗理解
   1. 进程 类似 一条生成线
      1. 多进程 类似 多条生产线, 
   2. 线程 类似 生成线上的一个工人
      1. 多个线程 类似多个工人
   3. 协程 类似 等待的一个工人 去做其他的事
      1. 一个线程 等待时 做其他事, 做 多个事
2. 简单总结
   1. 进程
      1. 资源分配的单位
      2. 切换进程要的很最大的资源，效率很低
   2. 线程
      1.  操作系统**调度**的单位
      2. 切换需要的资源一般，效率一般（不考虑GIL的情况）
   3. 协程  切换任务资源很小，效率高
   4. 多进程、多线程根据 cpu核数 可能是 **并行或并发** .  协程 在一个线程中 是 **并发**

#### 7.7 并发下载器

1. 并发下载原理

   1. ```
      from gevent import monkey
      import gevent
      import urllib.request
      
      #耗时 操作时 需要
      monkey.patch_all()
      
      def my_downLoad(url):
          print('GET: %s' % url)
          resp = urllib.request.urlopen(url)
          data = resp.read()
          print('%d bytes received from %s.' % (len(data), url))
      
      gevent.joinall([
              gevent.spawn(my_downLoad, 'http://www.baidu.com/'),
              gevent.spawn(my_downLoad, 'http://www.itcast.cn/'),
              gevent.spawn(my_downLoad, 'http://www.itheima.com/'),
      ])
```

   2. 运行结果

      ```
      GET: http://www.baidu.com/
      GET: http://www.itcast.cn/
      GET: http://www.itheima.com/
      111327 bytes received from http://www.baidu.com/.
      172054 bytes received from http://www.itheima.com/.
      215035 bytes received from http://www.itcast.cn/.
      ```

   3. 总结:
      1. 用协程gevent 实现的
      2. 先发送的获取baidu的相关信息，然后交替是itcast、itheima
      3. 但是收到数据的先后顺序 不一定 与发送顺序相同，体现了异步, 即: 不确定什么时候会收到数据，顺序不一定

2. 实现多个视频下载

   1. ```
      from gevent import monkey
      import gevent
      import urllib.request
      
      #有IO才做时需要这一句
      monkey.patch_all()
      
      def my_downLoad(file_name, url):
          print('GET: %s' % url)
          resp = urllib.request.urlopen(url)
          data = resp.read()
      
          with open(file_name, "wb") as f:
              f.write(data)
      
          print('%d bytes received from %s.' % (len(data), url))
      
      gevent.joinall([
              gevent.spawn(my_downLoad, "1.mp4", 'http://oo52bgdsl.bkt.clouddn.com/05day-08-%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89.mp4'),
              gevent.spawn(my_downLoad, "2.mp4", 'http://oo52bgdsl.bkt.clouddn.com/05day-03-%E3%80%90%E6%8E%8C%E6%8F%A1%E3%80%91%E6%97%A0%E5%8F%82%E6%95%B0%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E8%B0%83%E7%94%A8%28%E4%B8%8B%29.mp4'),
      ])
      ```

      1.  gevent 实现协程
      2. monkey.patch_all() 与 gevent.joinall()  配合 实现 协程自动切换



#### 7 协程  - 总结  

C++没有, python有

##### 01-迭代器

1. 判断isinstance()

   1. ```
      from collections import Iterable
      isinstance([], Iterable)
      ```

2. 可以for语句

3. 迭代类

   ```
   import time
   from collections import Iterable
   from collections import Iterator
   
   #可迭代对象类
   class Classmate():
   	de __init__(self):
   		#数据结构list
   		self.names = list()
       
       def add(self, name):
       	self.names.append(name)
       	
   	def __iter__(self):  #1 必须实现__iter__方法, 2 必须返回迭代器类的对象,可以for	
   		return ClassIterator(self)  #返回对象引用(迭代器类对象), 必须的
   		
   
   class ClassIterator():  #迭代器类: 必须有__iter__, __next__方法
   	def __init__(self, obj):
   		self.obj = ojb
   		#list的索引index
   		self.current_num = 0
   	def __iter__(self):
   		pass
   		
       def __next__(self): 
       	if self.current_num < len(self.obj.names):
       		ret = self.obj.names[self.current_num]
       		return ret
       	else:
       		raise StopIteration  # 抛出异常
   #创建可迭代对象
   classmate = Classmate()
   classmate.add("laow")
   classmate.add("wange")
   classmate.add("laoz")
   
   # 判断可迭代对象
   isinstance(classmate, Iterable)
   
   #创建迭代器(对象)
   classmate_iterator = iter(classmate)
   #判断迭代器
   isinstance(classmate_iterator, Iterator)
   
   # 1. 先判断classmate是可迭代对象(有__iter__方法) 
   # 2. 返回值是对象, for调用这个对象的__next__方法, for每调用一次__next__方法返回一个值,该值赋值给name
   for name in classmate:  #classmate是ClassIterator类的对象, 
   	print(name)
   ```

   1. 可迭代对象
   2. `iter(对象)`  
      1. 得到` __iter__`方法的返回值
      2. ` __iter__` 返回值: 一个迭代器(对象)

4. 对象A的类中有`__iter(self)__`方法, 对象A可迭代的,

   1. 类A的`__iter__(self)` 返回值是另一个对象B,  返回值B是迭代器
   2.  类B有`__iter__(self),__next__(self)__`, 则类B的对象叫迭代器 .
   3. for循环, 自动调用`迭代器` 的`__next__`方法

   

##### 02-完善迭代器

1. ```
   import time
   from collections import Iterable
   from collections import Iterator
   
   #定义迭代器类
   class Classmate():
       def __init__(self):
           self.names = list()
           self.current_num = 0
       
       def add(self, name):
           self.names.append(name)
           
       def __iter__(self):  #1.必须实现__iter__方法, 2.返回迭代器的对象, 此时可以for	
           return self  #返回对象引用, 必须的
       
       def __next__(self): 
           if self.current_num < len(self.names):
               ret = self.names[self.current_num]
               self.current_num += 1
               return ret
           else:
               raise StopIteration  # 抛出异常
   
   classmate = Classmate() # 返回迭代器对象
   classmate.add("laow")
   classmate.add("wange")
   classmate.add("laoz")
   
   
   #1. 先判断classmate是可迭代对象(有__iter__方法) 
   #2. 返回值是对象, for调用这个对象的__next__方法, for每调用一次__next__方法返回一个值,该值赋值给name
for name in classmate: 
       print(name)
   ```
   
   1. 迭代器是可迭代的, 反之不一定
   2. 迭代器对象 可用for 循环取值
   3. 迭代器对象 代表生成值的方式,  先 iter()方法 return对象, 再用next(迭代器) 方法return一个值

##### 03-（重点）迭代器的应用

1. 对比

   1. python2中
   1. rang(10)   # 返回list
      2. xrange(10)  #  返回生成值的方式. 迭代器对象,
   
2. python3: 
      
1. range(10)   # 返回 range(0, 10)
      
2. 迭代器 占用空间 很小

3. 迭代器 Fibonacci

   ```
   class Fibonacci(object):
   	def __init__(self, all_num):
   		self.all_num = all_num
   		self.current_num = 0
   		self.a = 0
   		self.b = 1
   		
   	def __iter__(self):
   		return self
   		
   	def __next__(self):
   		if self.current_num < self.all_num:
   			ret = self.a
   			
   			self.a, self.b = self.b, self.a + self.b
   			self.current_num += 1
   			
   			return ret
           else:
          		raise StopIteration
   
   fibo = Fibonacci(10)
   
   for num in fibo:
   	print(num)
   ```

   

4. linux:

   1. 全部替换: (命令模式) `: %s/C/A/g`,   #%s/要改的/改成的/g,  3个/

##### 04-迭代器使用的其他方式

1.  for 使用迭代器
2. list, tuple 也接收迭代器

##### 05-生成器-1 - yield方式

1. 特殊的迭代器,  返回生成器对象, 函数样子的类,

2. 列表推导式 [] 换成 ()  # 生成器

   `nums = ( x*x for x in range(10))   #  nums =[ x*x for x in range(10))]`

3. 函数-->生成器   #  有 yield 

   ```
   def fib(n):
   	a, b = 0, 1
   	current_num = 0
   	while current_num < all_num:
   		yield a # 返回a,并停止, 等待next()函数从此次启动
   		a, b = b, a + b
   
   # 调用fib时, 发现函数有yield, 此时不是调用函数, 是创建一个生成器对象
   obj = fib(10)    # obj类型class 'generator'
   
   ret = next(obj)
   print(ret)   # 1
   
   ret = next(obj)
   printn(ret)  # 2
   ```

   1. next() 方法, 但没有next() 语句
   2.  生成器, 函数样子的类

##### 06-生成器的启动

1. next(生成器对象) 启动,  `ret.value` 返回值

   ```
   def fib(n):
   	a, b = 0, 1
   	current_num = 0
   	while current_num < all_num:
   		yield a # 返回a,并停止, 等待next()函数从此处启动
   		a, b = b, a + b
   		
       return 'OK--'   # return语句可以没有
       
   obj = fib(10)
   while True: 
   	try:
   		ret = next(obj)
   	exception Exception as ret:
   		print(ret.value)   # 输出OK--
   	
   ```

2.  生成器对象.send(参数) 启动, 传递参数

   ```
   def fib(all_num):
       a, b = 0, 1
       current_num = 0
       while current_num < all_num:
       	# yield不赋值给ret, 
           ret = yield a  # 1 先执行右侧返回a,并停止.2等待next()启动.3若send,参数赋给ret, 
           print('a',a)
           print(">>ret>>", ret)
           a, b = b, a + b
           current_num += 1
   		
       
   obj = fib(10)
   
   ret = next(obj)
   print(ret)
   
   ret = obj.send("hahah")  # send参数传给ret
   print(ret)
   ```

3. linux: 

   1. `D` 光标后全删,
2. `d0` 光标前删除
   
   

##### 07-（重点）生成器-小总结

1. 迭代器: `__iter__`, `__next__`,  `return 生成数据的代码`, 节省内存空, 实现循环
2. 生成器: 特殊的迭代器, 可通过next(), 或 send() 不断取下一个值
3. 都是保存生成代码, 不是保存结果

##### 08-用yield完成多任务

1. 协程: 

   1. 协程是python个中另外一种实现多任务的方式
   2. 在一个线程中,某个函数可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行.  
   3. 不是通过调用函数实现

   

1. 进程: 要分配资源, 释放资源, 效率小于线程.

   线程: 比协程的效率小. 协程像执行一个函数一样执行两个任务

3. yield 实现协程

   1. ```
      def task_1():
      	while True:
      		print("---1---")
      		yield 
      		
      def task_2():
      	while True:
      		print("---2---")
      		yield
      		
      def main():
      	t1 = task_1()
      	t2 = task_2()
      	while True:
      		next(t1)
      		next(t2)
      		
      if __name__ =='__main__':
      	main()
      ```

   2. yield 实现任务切换, 实现多任务. 一个任务对应一个方法

##### 09-使用greenlet、gevent完成多任务

1. greenlet 

   1. greenlet 封装yield, 实现协程

   2. ```
      #coding=utf-8
      
      from greenlet import greenlet
      import time
      
      def test1():
          while True:
              print "---A--"
              gr2.switch()
              time.sleep(0.5)  #遇到延时要等待
      
      def test2():
          while True:
              print "---B--"
              gr1.switch()
              time.sleep(0.5)
      
      gr1 = greenlet(test1)  #全局变量
      gr2 = greenlet(test2)
      
      #切换到gr1中运行
      gr1.switch()    #运行
      ```

      1. gr1.switch()  # 运行开始

   3. ```
      sudo pip3 install greenlet
      ```

2. gevent

   1. 封装greenlet

   2. ```
      from gevent import monkey
      import gevent
      import random
      import time
      
      # 有耗时操作时需要
      # 程序中耗时代码，换为gevent中自己实现的模块
      # time.sleep()转为gevent.sleep()
      monkey.patch_all()  
      
      def coroutine_work(coroutine_name):
          for i in range(10):
              print(coroutine_name, i)
              time.sleep(random.random())
      
      gevent.joinall([
              gevent.spawn(coroutine_work, "work1"),
              gevent.spawn(coroutine_work, "work2")
      ])
      
      #g1 = gevent.spawn(f, 5)
      #g2 = gevent.spawn(f, 5)
      #g1.join()  # 从join() 开启协程
      #g2.join()
      
      ```

      1. monkey.patch_all() 把延时代码转为gevent延时代码
      2. gevent.joinall([])  代替.join() 语句

   3. ```python
      pip3 install gevent
      ```

##### 10-案例：图片下载器

1. 协程:  
   1. 用gevent
   2. yield, greenlet是协程的原理, 不要用

2. ```
   from gevent import monkey
   import gevent
   import urllib.request
   
   #耗时操作时需要
   monkey.patch_all()
   
   def my_downLoad(url):
       print('GET: %s' % url)
       resp = urllib.request.urlopen(url)
       data = resp.read()
       print('%d bytes received from %s.' % (len(data), url))
   
   gevent.joinall([
           gevent.spawn(my_downLoad, 'http://www.baidu.com/'),
           gevent.spawn(my_downLoad, 'http://www.itcast.cn/'),
           gevent.spawn(my_downLoad, 'http://www.itheima.com/'),
   ])
   ```

   

3.  开发工具: sublime开发,  用终端去运行, 特别复杂的很多文件夹时用pycharm开发

##### 11-（重点）进程、线程、协程对比

1. 效率从高到低: 协程 > 线程 >进程
2. 协程 利用 进程 等待的时间执行任务